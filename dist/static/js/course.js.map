{"version":3,"sources":["webpack:///static/js/course.js","webpack:///webpack/bootstrap 8a78be20f85ddde7b936","webpack:///./src/js/modules/header.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/js/modules/prompt.js","webpack:///./src/js/lib/jquery.bxslide.js","webpack:///./src/js/course.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","_prompt","pop","timer","loginInfo","$","tipsUser","on","clearTimeout","show","ajax","url","data","success","json","plan","today_complete_rate","attr","html","setTimeout","hide","btnSoso","soso","val","length","window","open","keyup","document","keypress","e","which","location","hostname","ajaxSetup","beforeSend","xhr","settings","setRequestHeader","WXJY","csrfToken","statusCode","200","mess","code","message","401","href","500","error","withCredentials","g","this","Function","eval","txt","color","appendTo","bg","text","css","removeClass","addClass","value","defaults","mode","slideSelector","infiniteLoop","hideControlOnEnd","speed","easing","slideMargin","startSlide","randomStart","captions","ticker","tickerHover","adaptiveHeight","adaptiveHeightSpeed","video","useCSS","preloadImages","responsive","slideZIndex","wrapperClass","touchEnabled","swipeThreshold","oneToOneTouch","preventDefaultSwipeX","preventDefaultSwipeY","ariaLive","ariaHidden","keyboardEnabled","pager","pagerType","pagerShortSeparator","pagerSelector","buildPager","pagerCustom","controls","nextText","prevText","nextSelector","prevSelector","autoControls","startText","stopText","autoControlsCombine","autoControlsSelector","auto","pause","autoStart","autoDirection","stopAutoOnClick","autoHover","autoDelay","autoSlideForOnePage","minSlides","maxSlides","moveSlides","slideWidth","shrinkItems","onSliderLoad","onSlideBefore","onSlideAfter","onSlideNext","onSlidePrev","onSliderResize","onAutoChange","fn","bxSlider","options","each","slider","el","windowWidth","width","windowHeight","height","init","extend","parseInt","children","Math","floor","random","active","index","carousel","minThreshold","maxThreshold","working","interval","animProp","usingCSS","div","createElement","props","undefined","style","cssPrefix","replace","toLowerCase","setup","preloadSelector","eq","wrap","viewport","parent","loader","prepend","position","overflow","maxWidth","getViewportMaxWidth","float","listStyle","getSlideWidth","zIndex","display","appendCaptions","last","getPagerQty","fitVids","appendControls","appendControlsAuto","appendPager","after","loadElements","start","selector","callback","total","find","count","one","complete","src","trigger","slice","sliceAppend","clone","slicePrepend","append","remove","setSlidePosition","getViewportHeight","redrawSlider","initialized","bind","resizeWindow","initAuto","initTicker","updatePagerActive","updateDirectionControls","initTouch","keydown","keyPress","currentIndex","getMoveBy","add","outerHeight","max","apply","map","parseFloat","newElWidth","wrapWidth","ceil","getNumberSlidesShowing","slidesShowing","childWidth","first","pagerQty","breakPoint","counter","lastChild","lastShowingIndex","setPositionProperty","left","outerWidth","top","type","duration","params","animateObj","propValue","target","is","unbind","updateAfterSlideTransition","resetValue","tickerLoop","animate","populatePager","pagerHtml","linkContent","isFunction","pagerEl","clickPagerBind","next","prev","clickNextBind","clickPrevBind","directionEl","stop","autoEl","clickStartBind","clickStopBind","updateAutoControls","title","preventDefault","hasClass","stopAuto","goToNextSlide","goToPrevSlide","startAuto","pagerLink","pagerIndex","currentTarget","goToSlide","slideIndex","len","oldIndex","state","windowFocusHandler","windowBlurHandler","focus","blur","hover","autoPaused","transform","idx","ratio","newSpeed","totalDimens","startPosition","split","abs","resumeSpeed","animateProperty","reset","isOnScreen","win","scrollTop","scrollLeft","bounds","offset","right","bottom","activeElementTag","activeElement","tagName","tagFilters","RegExp","result","exec","keyCode","touch","x","y","end","onTouchStart","originalPos","orig","originalEvent","touchPoints","changedTouches","pageX","pageY","setPointerCapture","pointerId","onTouchMove","onTouchEnd","onPointerCancel","releasePointerCapture","xMovement","yMovement","change","distance","windowWidthNew","windowHeightNew","applyAriaHiddenAttributes","startVisibleIndex","numberOfSlidesShowing","setSlideIndex","direction","requestEl","performTransition","moveBy","filter","fadeOut","fadeIn","preventControlUpdate","setInterval","clearInterval","getCurrentSlide","getCurrentSlideElement","getSlideElement","getSlideCount","isWorking","destroySlider","removeAttr","unwrap","removeData","off","reloadSlider","jQuery","click","siblings"],"mappings":"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","file":"static/js/course.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _prompt = __webpack_require__(2);\n\nglobal.pop = _prompt.pop;\n// 导航\nvar timer = null;\nvar loginInfo = $('.js-login-info');\nvar tipsUser = $('.js-tips-user');\nloginInfo.on('mouseenter', function () {\n    clearTimeout(timer);\n    tipsUser.show();\n    $.ajax({\n        url: '/api/plan/info',\n        data: {},\n        success: function success(json) {\n            if (json && json.plan) {\n                var plan = json.plan;\n                var today_complete_rate = plan.today_complete_rate;\n                $('.circle circle[stroke-dasharray]').attr('stroke-dasharray', today_complete_rate * 2 + ' ' + (200 - today_complete_rate * 2));\n                $('.circle span').html(today_complete_rate + '%');\n            }\n        }\n    });\n});\nloginInfo.on('mouseleave', function () {\n    timer = setTimeout(function () {\n        tipsUser.hide();\n    }, 300);\n});\n\ntipsUser.on('mouseenter', function () {\n    clearTimeout(timer);\n});\n\ntipsUser.on('mouseleave', function () {\n    timer = setTimeout(function () {\n        tipsUser.hide();\n    }, 300);\n});\n\nvar btnSoso = $('.page-header__search .butn-soso');\nbtnSoso.on('click', function () {\n    // console.info(\"RUN\");\n    var soso = $('.page-header__search input').val();\n    if (soso && soso.length > 0) {\n        window.open('/search?keywords=' + soso, '_blank');\n        $('.page-header__search input').val('');\n        // console.info(soso);\n    }\n});\n$(\".page-header__search input\").keyup(function () {\n    $(document).keypress(function (e) {\n        // 回车键事件\n        if (e.which == 13) {\n            var soso = $('.page-header__search input').val();\n            if (soso && soso.length > 0) {\n                window.open('/search?keywords=' + soso, '_blank');\n                // console.info(soso);\n            }\n        }\n    });\n});\nif (location.hostname == 'localhost') {\n    $.ajaxSetup({\n        beforeSend: function beforeSend(xhr, settings) {\n            xhr.setRequestHeader(\"Authorization\", \"Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjU0MDQ0MDQxZDA0M2RjMDgyYWJjNDA4OTg2OTlmZjc5ZjFmNzA0ZDgxNzEwNGYwYjVmYmYzY2ZjZjhmOWM4MTdiMzBhYjRiOWNmMTk3NDUyIn0.eyJhdWQiOiI2IiwianRpIjoiNTQwNDQwNDFkMDQzZGMwODJhYmM0MDg5ODY5OWZmNzlmMWY3MDRkODE3MTA0ZjBiNWZiZjNjZmNmOGY5YzgxN2IzMGFiNGI5Y2YxOTc0NTIiLCJpYXQiOjE1MjA2NzcxMDgsIm5iZiI6MTUyMDY3NzEwOCwiZXhwIjoxNTUyMjEzMTA4LCJzdWIiOiI4Iiwic2NvcGVzIjpbXX0.3irFbm_3KpOt6F4RsqJBsNH6NnvagJqLbRX3gPl_8uCJySMYpBBvDTXtMTmNqxTg02qviGTkw2gQw0e366keWAwP9ShKHfZQlS3uOINUzNBciB5BUFwP7PdFpgyPXVs5aCSU48Bmwb-QAZEv2rrX5CYGF0cxYjvDRjFWrGJwSiED9lxRva78057ioFicMeGsdVZjacqjzHzEi4EQHbaYt3KgT6z3EucFXcxk5ZyB9wlaXtdfrJ1JlPA4rv4bN-m6AYUVXOFy_XKLUU2_13xYIL3a0qVCL6_xMQxIueHvdi-46gwvTIkKfmbJSSpOcfuuUp3SG0i7YA4d5XArXuGRKO4iQ8aFQ0KBh8ot5n5MfdSVK9ZpA5-Ym-5O1NSbcnxDHYWj2XGzwqoSQrLGP9R-ijX0eITN7rcGfnIEgHYTwgIya8O7Rd6qqvQ-QCgX5PuxSSwlvBKpf49ENJxrX_CQY0d8Fh0R6zB5orsEzR6wQhOhzTi0OJuTgRq6V9Qc91PGBZVJKwE3Xxip3Mcf3wxTKEKgAdBb-I5cSbVgeZJN4eIC5ik0ASLrSaroQyMLe9xT7OOCnm1vA-A6iEWJcx7NIzsrfhEtCgSDs11pnQr70ltgLSdYoWi8NwSXpo37EP4io8ozRCC2qnuE3TlfqMzgJ14AlgXmipySWhhVrhuKtzw\");\n            settings.url = \"http://wxjy-mingyang.mion.cn\" + settings.url;\n        }\n    });\n} else {\n    $.ajaxSetup({\n        beforeSend: function beforeSend(xhr) {\n            window.WXJY = WXJY || {};\n            if (typeof WXJY.csrfToken !== 'undefined') {\n                xhr.setRequestHeader(\"X-CSRF-TOKEN\", WXJY.csrfToken);\n            }\n        }\n    });\n}\n$.ajaxSetup({\n    statusCode: {\n        200: function _(mess) {\n            if (!mess.code == 0) {\n                (0, _prompt.pop)(mess.message, '#fa8c16');\n            }\n        },\n        401: function _() {\n            window.location.href = '/login';\n        },\n        500: function _() {\n            (0, _prompt.pop)('网络异常，请稍后再试', 'red');\n        }\n    },\n    error: function error(mess) {\n        if (mess.error == 'Unauthenticated.') {\n            window.location.href = '/login';\n        }\n    },\n    withCredentials: true\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar g;\n\n// This works in non-strict mode\ng = (function () {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n//提示框动画\n\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\nfunction pop(txt, color) {\n    if (!$('.popprompt')[0]) {\n        $('<div class=\"popprompt\">看什么看，做题</div>').appendTo('body');\n    }\n    var bg = color ? color : '#00e290';\n    $('.popprompt').text('').text(txt).css('background', bg).removeClass('off').addClass('on');\n    setTimeout(function () {\n        $('.popprompt').removeClass('on').addClass('off');\n    }, 2000);\n}\n\nexports.pop = pop;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\r\n * bxSlider v4.2.12\r\n * Copyright 2013-2015 Steven Wanderski\r\n * Written while drinking Belgian ales and listening to jazz\r\n * Licensed under MIT (http://opensource.org/licenses/MIT)\r\n */\n\n\n\n;(function ($) {\n\n  var defaults = {\n\n    // GENERAL\n    mode: 'horizontal',\n    slideSelector: '',\n    infiniteLoop: true,\n    hideControlOnEnd: false,\n    speed: 800,\n    easing: null,\n    slideMargin: 0,\n    startSlide: 0,\n    randomStart: false,\n    captions: false,\n    ticker: false,\n    tickerHover: false,\n    adaptiveHeight: false,\n    adaptiveHeightSpeed: 800,\n    video: false,\n    useCSS: true,\n    preloadImages: 'visible',\n    responsive: true,\n    slideZIndex: 50,\n    wrapperClass: 'bx-wrapper',\n\n    // TOUCH\n    touchEnabled: true,\n    swipeThreshold: 50,\n    oneToOneTouch: true,\n    preventDefaultSwipeX: true,\n    preventDefaultSwipeY: false,\n\n    // ACCESSIBILITY\n    ariaLive: true,\n    ariaHidden: true,\n\n    // KEYBOARD\n    keyboardEnabled: false,\n\n    // PAGER\n    pager: true,\n    pagerType: 'full',\n    pagerShortSeparator: ' / ',\n    pagerSelector: null,\n    buildPager: null,\n    pagerCustom: null,\n\n    // CONTROLS\n    controls: true,\n    nextText: 'Next',\n    prevText: 'Prev',\n    nextSelector: null,\n    prevSelector: null,\n    autoControls: false,\n    startText: 'Start',\n    stopText: 'Stop',\n    autoControlsCombine: false,\n    autoControlsSelector: null,\n\n    // AUTO\n    auto: true,\n    pause: 4000,\n    autoStart: true,\n    autoDirection: 'next',\n    stopAutoOnClick: false,\n    autoHover: true,\n    autoDelay: 0,\n    autoSlideForOnePage: false,\n\n    // CAROUSEL\n    minSlides: 1,\n    maxSlides: 1,\n    moveSlides: 0,\n    slideWidth: 0,\n    shrinkItems: false,\n\n    // CALLBACKS\n    onSliderLoad: function onSliderLoad() {\n      return true;\n    },\n    onSlideBefore: function onSlideBefore() {\n      return true;\n    },\n    onSlideAfter: function onSlideAfter() {\n      return true;\n    },\n    onSlideNext: function onSlideNext() {\n      return true;\n    },\n    onSlidePrev: function onSlidePrev() {\n      return true;\n    },\n    onSliderResize: function onSliderResize() {\n      return true;\n    },\n    onAutoChange: function onAutoChange() {\n      return true;\n    } //calls when auto slides starts and stops\n  };\n\n  $.fn.bxSlider = function (options) {\n\n    if (this.length === 0) {\n      return this;\n    }\n\n    // support multiple elements\n    if (this.length > 1) {\n      this.each(function () {\n        $(this).bxSlider(options);\n      });\n      return this;\n    }\n\n    // create a namespace to be used throughout the plugin\n    var slider = {},\n\n    // set a reference to our slider element\n    el = this,\n\n    // get the original window dimens (thanks a lot IE)\n    windowWidth = $(window).width(),\n        windowHeight = $(window).height();\n\n    // Return if slider is already initialized\n    if ($(el).data('bxSlider')) {\n      return;\n    }\n\n    /**\r\n     * ===================================================================================\r\n     * = PRIVATE FUNCTIONS\r\n     * ===================================================================================\r\n     */\n\n    /**\r\n     * Initializes namespace settings to be used throughout plugin\r\n     */\n    var init = function init() {\n      // Return if slider is already initialized\n      if ($(el).data('bxSlider')) {\n        return;\n      }\n      // merge user-supplied options with the defaults\n      slider.settings = $.extend({}, defaults, options);\n      // parse slideWidth setting\n      slider.settings.slideWidth = parseInt(slider.settings.slideWidth);\n      // store the original children\n      slider.children = el.children(slider.settings.slideSelector);\n      // check if actual number of slides is less than minSlides / maxSlides\n      if (slider.children.length < slider.settings.minSlides) {\n        slider.settings.minSlides = slider.children.length;\n      }\n      if (slider.children.length < slider.settings.maxSlides) {\n        slider.settings.maxSlides = slider.children.length;\n      }\n      // if random start, set the startSlide setting to random number\n      if (slider.settings.randomStart) {\n        slider.settings.startSlide = Math.floor(Math.random() * slider.children.length);\n      }\n      // store active slide information\n      slider.active = { index: slider.settings.startSlide };\n      // store if the slider is in carousel mode (displaying / moving multiple slides)\n      slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1 ? true : false;\n      // if carousel, force preloadImages = 'all'\n      if (slider.carousel) {\n        slider.settings.preloadImages = 'all';\n      }\n      // calculate the min / max width thresholds based on min / max number of slides\n      // used to setup and update carousel slides dimensions\n      slider.minThreshold = slider.settings.minSlides * slider.settings.slideWidth + (slider.settings.minSlides - 1) * slider.settings.slideMargin;\n      slider.maxThreshold = slider.settings.maxSlides * slider.settings.slideWidth + (slider.settings.maxSlides - 1) * slider.settings.slideMargin;\n      // store the current state of the slider (if currently animating, working is true)\n      slider.working = false;\n      // initialize the controls object\n      slider.controls = {};\n      // initialize an auto interval\n      slider.interval = null;\n      // determine which property to use for transitions\n      slider.animProp = slider.settings.mode === 'vertical' ? 'top' : 'left';\n      // determine if hardware acceleration can be used\n      slider.usingCSS = slider.settings.useCSS && slider.settings.mode !== 'fade' && (function () {\n        // create our test div element\n        var div = document.createElement('div'),\n\n        // css transition properties\n        props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];\n        // test for each property\n        for (var i = 0; i < props.length; i++) {\n          if (div.style[props[i]] !== undefined) {\n            slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();\n            slider.animProp = '-' + slider.cssPrefix + '-transform';\n            return true;\n          }\n        }\n        return false;\n      })();\n      // if vertical mode always make maxSlides and minSlides equal\n      if (slider.settings.mode === 'vertical') {\n        slider.settings.maxSlides = slider.settings.minSlides;\n      }\n      // save original style data\n      el.data('origStyle', el.attr('style'));\n      el.children(slider.settings.slideSelector).each(function () {\n        $(this).data('origStyle', $(this).attr('style'));\n      });\n\n      // perform all DOM / CSS modifications\n      setup();\n    };\n\n    /**\r\n     * Performs all DOM and CSS modifications\r\n     */\n    var setup = function setup() {\n      var preloadSelector = slider.children.eq(slider.settings.startSlide); // set the default preload selector (visible)\n\n      // wrap el in a wrapper\n      el.wrap('<div class=\"' + slider.settings.wrapperClass + '\"><div class=\"bx-viewport\"></div></div>');\n      // store a namespace reference to .bx-viewport\n      slider.viewport = el.parent();\n\n      // add aria-live if the setting is enabled and ticker mode is disabled\n      if (slider.settings.ariaLive && !slider.settings.ticker) {\n        slider.viewport.attr('aria-live', 'polite');\n      }\n      // add a loading div to display while images are loading\n      slider.loader = $('<div class=\"bx-loading\" />');\n      slider.viewport.prepend(slider.loader);\n      // set el to a massive width, to hold any needed slides\n      // also strip any margin and padding from el\n      el.css({\n        width: slider.settings.mode === 'horizontal' ? slider.children.length * 1000 + 215 + '%' : 'auto',\n        position: 'relative'\n      });\n      // if using CSS, add the easing property\n      if (slider.usingCSS && slider.settings.easing) {\n        el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);\n        // if not using CSS and no easing value was supplied, use the default JS animation easing (swing)\n      } else if (!slider.settings.easing) {\n          slider.settings.easing = 'swing';\n        }\n      // make modifications to the viewport (.bx-viewport)\n      slider.viewport.css({\n        width: '100%',\n        overflow: 'hidden',\n        position: 'relative'\n      });\n      slider.viewport.parent().css({\n        maxWidth: getViewportMaxWidth()\n      });\n      // apply css to all slider children\n      slider.children.css({\n        // the float attribute is a reserved word in compressors like YUI compressor and need to be quoted #48\n        'float': slider.settings.mode === 'horizontal' ? 'left' : 'none',\n        listStyle: 'none',\n        position: 'relative'\n      });\n      // apply the calculated width after the float is applied to prevent scrollbar interference\n      slider.children.css('width', getSlideWidth());\n      // if slideMargin is supplied, add the css\n      if (slider.settings.mode === 'horizontal' && slider.settings.slideMargin > 0) {\n        slider.children.css('marginRight', slider.settings.slideMargin);\n      }\n      if (slider.settings.mode === 'vertical' && slider.settings.slideMargin > 0) {\n        slider.children.css('marginBottom', slider.settings.slideMargin);\n      }\n      // if \"fade\" mode, add positioning and z-index CSS\n      if (slider.settings.mode === 'fade') {\n        slider.children.css({\n          position: 'absolute',\n          zIndex: 0,\n          display: 'none'\n        });\n        // prepare the z-index on the showing element\n        slider.children.eq(slider.settings.startSlide).css({ zIndex: slider.settings.slideZIndex, display: 'block' });\n      }\n      // create an element to contain all slider controls (pager, start / stop, etc)\n      slider.controls.el = $('<div class=\"bx-controls\" />');\n      // if captions are requested, add them\n      if (slider.settings.captions) {\n        appendCaptions();\n      }\n      // check if startSlide is last slide\n      slider.active.last = slider.settings.startSlide === getPagerQty() - 1;\n      // if video is true, set up the fitVids plugin\n      if (slider.settings.video) {\n        el.fitVids();\n      }\n      if (slider.settings.preloadImages === 'all' || slider.settings.ticker) {\n        preloadSelector = slider.children;\n      }\n      // only check for control addition if not in \"ticker\" mode\n      if (!slider.settings.ticker) {\n        // if controls are requested, add them\n        if (slider.settings.controls) {\n          appendControls();\n        }\n        // if auto is true, and auto controls are requested, add them\n        if (slider.settings.auto && slider.settings.autoControls) {\n          appendControlsAuto();\n        }\n        // if pager is requested, add it\n        if (slider.settings.pager) {\n          appendPager();\n        }\n        // if any control option is requested, add the controls wrapper\n        if (slider.settings.controls || slider.settings.autoControls || slider.settings.pager) {\n          slider.viewport.after(slider.controls.el);\n        }\n        // if ticker mode, do not allow a pager\n      } else {\n          slider.settings.pager = false;\n        }\n      loadElements(preloadSelector, start);\n    };\n\n    var loadElements = function loadElements(selector, callback) {\n      var total = selector.find('img:not([src=\"\"]), iframe').length,\n          count = 0;\n      if (total === 0) {\n        callback();\n        return;\n      }\n      selector.find('img:not([src=\"\"]), iframe').each(function () {\n        $(this).one('load error', function () {\n          if (++count === total) {\n            callback();\n          }\n        }).each(function () {\n          if (this.complete || this.src == '') {\n            $(this).trigger('load');\n          }\n        });\n      });\n    };\n\n    /**\r\n     * Start the slider\r\n     */\n    var start = function start() {\n      // if infinite loop, prepare additional slides\n      if (slider.settings.infiniteLoop && slider.settings.mode !== 'fade' && !slider.settings.ticker) {\n        var slice = slider.settings.mode === 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides,\n            sliceAppend = slider.children.slice(0, slice).clone(true).addClass('bx-clone'),\n            slicePrepend = slider.children.slice(-slice).clone(true).addClass('bx-clone');\n        if (slider.settings.ariaHidden) {\n          sliceAppend.attr('aria-hidden', true);\n          slicePrepend.attr('aria-hidden', true);\n        }\n        el.append(sliceAppend).prepend(slicePrepend);\n      }\n      // remove the loading DOM element\n      slider.loader.remove();\n      // set the left / top position of \"el\"\n      setSlidePosition();\n      // if \"vertical\" mode, always use adaptiveHeight to prevent odd behavior\n      if (slider.settings.mode === 'vertical') {\n        slider.settings.adaptiveHeight = true;\n      }\n      // set the viewport height\n      slider.viewport.height(getViewportHeight());\n      // make sure everything is positioned just right (same as a window resize)\n      el.redrawSlider();\n      // onSliderLoad callback\n      slider.settings.onSliderLoad.call(el, slider.active.index);\n      // slider has been fully initialized\n      slider.initialized = true;\n      // bind the resize call to the window\n      if (slider.settings.responsive) {\n        $(window).bind('resize', resizeWindow);\n      }\n      // if auto is true and has more than 1 page, start the show\n      if (slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)) {\n        initAuto();\n      }\n      // if ticker is true, start the ticker\n      if (slider.settings.ticker) {\n        initTicker();\n      }\n      // if pager is requested, make the appropriate pager link active\n      if (slider.settings.pager) {\n        updatePagerActive(slider.settings.startSlide);\n      }\n      // check for any updates to the controls (like hideControlOnEnd updates)\n      if (slider.settings.controls) {\n        updateDirectionControls();\n      }\n      // if touchEnabled is true, setup the touch events\n      if (slider.settings.touchEnabled && !slider.settings.ticker) {\n        initTouch();\n      }\n      // if keyboardEnabled is true, setup the keyboard events\n      if (slider.settings.keyboardEnabled && !slider.settings.ticker) {\n        $(document).keydown(keyPress);\n      }\n    };\n\n    /**\r\n     * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value\r\n     */\n    var getViewportHeight = function getViewportHeight() {\n      var height = 0;\n      // first determine which children (slides) should be used in our height calculation\n      var children = $();\n      // if mode is not \"vertical\" and adaptiveHeight is false, include all children\n      if (slider.settings.mode !== 'vertical' && !slider.settings.adaptiveHeight) {\n        children = slider.children;\n      } else {\n        // if not carousel, return the single active child\n        if (!slider.carousel) {\n          children = slider.children.eq(slider.active.index);\n          // if carousel, return a slice of children\n        } else {\n            // get the individual slide index\n            var currentIndex = slider.settings.moveSlides === 1 ? slider.active.index : slider.active.index * getMoveBy();\n            // add the current slide to the children\n            children = slider.children.eq(currentIndex);\n            // cycle through the remaining \"showing\" slides\n            for (i = 1; i <= slider.settings.maxSlides - 1; i++) {\n              // if looped back to the start\n              if (currentIndex + i >= slider.children.length) {\n                children = children.add(slider.children.eq(i - 1));\n              } else {\n                children = children.add(slider.children.eq(currentIndex + i));\n              }\n            }\n          }\n      }\n      // if \"vertical\" mode, calculate the sum of the heights of the children\n      if (slider.settings.mode === 'vertical') {\n        children.each(function (index) {\n          height += $(this).outerHeight();\n        });\n        // add user-supplied margins\n        if (slider.settings.slideMargin > 0) {\n          height += slider.settings.slideMargin * (slider.settings.minSlides - 1);\n        }\n        // if not \"vertical\" mode, calculate the max height of the children\n      } else {\n          height = Math.max.apply(Math, children.map(function () {\n            return $(this).outerHeight(false);\n          }).get());\n        }\n\n      if (slider.viewport.css('box-sizing') === 'border-box') {\n        height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) + parseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));\n      } else if (slider.viewport.css('box-sizing') === 'padding-box') {\n        height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));\n      }\n\n      return height;\n    };\n\n    /**\r\n     * Returns the calculated width to be used for the outer wrapper / viewport\r\n     */\n    var getViewportMaxWidth = function getViewportMaxWidth() {\n      var width = '100%';\n      if (slider.settings.slideWidth > 0) {\n        if (slider.settings.mode === 'horizontal') {\n          width = slider.settings.maxSlides * slider.settings.slideWidth + (slider.settings.maxSlides - 1) * slider.settings.slideMargin;\n        } else {\n          width = slider.settings.slideWidth;\n        }\n      }\n      return width;\n    };\n\n    /**\r\n     * Returns the calculated width to be applied to each slide\r\n     */\n    var getSlideWidth = function getSlideWidth() {\n      var newElWidth = slider.settings.slideWidth,\n          // start with any user-supplied slide width\n      wrapWidth = slider.viewport.width(); // get the current viewport width\n      // if slide width was not supplied, or is larger than the viewport use the viewport width\n      if (slider.settings.slideWidth === 0 || slider.settings.slideWidth > wrapWidth && !slider.carousel || slider.settings.mode === 'vertical') {\n        newElWidth = wrapWidth;\n        // if carousel, use the thresholds to determine the width\n      } else if (slider.settings.maxSlides > 1 && slider.settings.mode === 'horizontal') {\n          if (wrapWidth > slider.maxThreshold) {\n            return newElWidth;\n          } else if (wrapWidth < slider.minThreshold) {\n            newElWidth = (wrapWidth - slider.settings.slideMargin * (slider.settings.minSlides - 1)) / slider.settings.minSlides;\n          } else if (slider.settings.shrinkItems) {\n            newElWidth = Math.floor((wrapWidth + slider.settings.slideMargin) / Math.ceil((wrapWidth + slider.settings.slideMargin) / (newElWidth + slider.settings.slideMargin)) - slider.settings.slideMargin);\n          }\n        }\n      return newElWidth;\n    };\n\n    /**\r\n     * Returns the number of slides currently visible in the viewport (includes partially visible slides)\r\n     */\n    var getNumberSlidesShowing = function getNumberSlidesShowing() {\n      var slidesShowing = 1,\n          childWidth = null;\n      if (slider.settings.mode === 'horizontal' && slider.settings.slideWidth > 0) {\n        // if viewport is smaller than minThreshold, return minSlides\n        if (slider.viewport.width() < slider.minThreshold) {\n          slidesShowing = slider.settings.minSlides;\n          // if viewport is larger than maxThreshold, return maxSlides\n        } else if (slider.viewport.width() > slider.maxThreshold) {\n            slidesShowing = slider.settings.maxSlides;\n            // if viewport is between min / max thresholds, divide viewport width by first child width\n          } else {\n              childWidth = slider.children.first().width() + slider.settings.slideMargin;\n              slidesShowing = Math.floor((slider.viewport.width() + slider.settings.slideMargin) / childWidth) || 1;\n            }\n        // if \"vertical\" mode, slides showing will always be minSlides\n      } else if (slider.settings.mode === 'vertical') {\n          slidesShowing = slider.settings.minSlides;\n        }\n      return slidesShowing;\n    };\n\n    /**\r\n     * Returns the number of pages (one full viewport of slides is one \"page\")\r\n     */\n    var getPagerQty = function getPagerQty() {\n      var pagerQty = 0,\n          breakPoint = 0,\n          counter = 0;\n      // if moveSlides is specified by the user\n      if (slider.settings.moveSlides > 0) {\n        if (slider.settings.infiniteLoop) {\n          pagerQty = Math.ceil(slider.children.length / getMoveBy());\n        } else {\n          // when breakpoint goes above children length, counter is the number of pages\n          while (breakPoint < slider.children.length) {\n            ++pagerQty;\n            breakPoint = counter + getNumberSlidesShowing();\n            counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();\n          }\n          return counter;\n        }\n        // if moveSlides is 0 (auto) divide children length by sides showing, then round up\n      } else {\n          pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());\n        }\n      return pagerQty;\n    };\n\n    /**\r\n     * Returns the number of individual slides by which to shift the slider\r\n     */\n    var getMoveBy = function getMoveBy() {\n      // if moveSlides was set by the user and moveSlides is less than number of slides showing\n      if (slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()) {\n        return slider.settings.moveSlides;\n      }\n      // if moveSlides is 0 (auto)\n      return getNumberSlidesShowing();\n    };\n\n    /**\r\n     * Sets the slider's (el) left or top position\r\n     */\n    var setSlidePosition = function setSlidePosition() {\n      var position, lastChild, lastShowingIndex;\n      // if last slide, not infinite loop, and number of children is larger than specified maxSlides\n      if (slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop) {\n        if (slider.settings.mode === 'horizontal') {\n          // get the last child's position\n          lastChild = slider.children.last();\n          position = lastChild.position();\n          // set the left position\n          setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);\n        } else if (slider.settings.mode === 'vertical') {\n          // get the last showing index's position\n          lastShowingIndex = slider.children.length - slider.settings.minSlides;\n          position = slider.children.eq(lastShowingIndex).position();\n          // set the top position\n          setPositionProperty(-position.top, 'reset', 0);\n        }\n        // if not last slide\n      } else {\n          // get the position of the first showing slide\n          position = slider.children.eq(slider.active.index * getMoveBy()).position();\n          // check for last slide\n          if (slider.active.index === getPagerQty() - 1) {\n            slider.active.last = true;\n          }\n          // set the respective position\n          if (position !== undefined) {\n            if (slider.settings.mode === 'horizontal') {\n              setPositionProperty(-position.left, 'reset', 0);\n            } else if (slider.settings.mode === 'vertical') {\n              setPositionProperty(-position.top, 'reset', 0);\n            }\n          }\n        }\n    };\n\n    /**\r\n     * Sets the el's animating property position (which in turn will sometimes animate el).\r\n     * If using CSS, sets the transform property. If not using CSS, sets the top / left property.\r\n     *\r\n     * @param value (int)\r\n     *  - the animating property's value\r\n     *\r\n     * @param type (string) 'slide', 'reset', 'ticker'\r\n     *  - the type of instance for which the function is being\r\n     *\r\n     * @param duration (int)\r\n     *  - the amount of time (in ms) the transition should occupy\r\n     *\r\n     * @param params (array) optional\r\n     *  - an optional parameter containing any variables that need to be passed in\r\n     */\n    var setPositionProperty = function setPositionProperty(value, type, duration, params) {\n      var animateObj, propValue;\n      // use CSS transform\n      if (slider.usingCSS) {\n        // determine the translate3d value\n        propValue = slider.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';\n        // add the CSS transition-duration\n        el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');\n        if (type === 'slide') {\n          // set the property value\n          el.css(slider.animProp, propValue);\n          if (duration !== 0) {\n            // bind a callback method - executes when CSS transition completes\n            el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function (e) {\n              //make sure it's the correct one\n              if (!$(e.target).is(el)) {\n                return;\n              }\n              // unbind the callback\n              el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n              updateAfterSlideTransition();\n            });\n          } else {\n            //duration = 0\n            updateAfterSlideTransition();\n          }\n        } else if (type === 'reset') {\n          el.css(slider.animProp, propValue);\n        } else if (type === 'ticker') {\n          // make the transition use 'linear'\n          el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');\n          el.css(slider.animProp, propValue);\n          if (duration !== 0) {\n            el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function (e) {\n              //make sure it's the correct one\n              if (!$(e.target).is(el)) {\n                return;\n              }\n              // unbind the callback\n              el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n              // reset the position\n              setPositionProperty(params.resetValue, 'reset', 0);\n              // start the loop again\n              tickerLoop();\n            });\n          } else {\n            //duration = 0\n            setPositionProperty(params.resetValue, 'reset', 0);\n            tickerLoop();\n          }\n        }\n        // use JS animate\n      } else {\n          animateObj = {};\n          animateObj[slider.animProp] = value;\n          if (type === 'slide') {\n            el.animate(animateObj, duration, slider.settings.easing, function () {\n              updateAfterSlideTransition();\n            });\n          } else if (type === 'reset') {\n            el.css(slider.animProp, value);\n          } else if (type === 'ticker') {\n            el.animate(animateObj, duration, 'linear', function () {\n              setPositionProperty(params.resetValue, 'reset', 0);\n              // run the recursive loop after animation\n              tickerLoop();\n            });\n          }\n        }\n    };\n\n    /**\r\n     * Populates the pager with proper amount of pages\r\n     */\n    var populatePager = function populatePager() {\n      var pagerHtml = '',\n          linkContent = '',\n          pagerQty = getPagerQty();\n      // loop through each pager item\n      for (var i = 0; i < pagerQty; i++) {\n        linkContent = '';\n        // if a buildPager function is supplied, use it to get pager link value, else use index + 1\n        if (slider.settings.buildPager && $.isFunction(slider.settings.buildPager) || slider.settings.pagerCustom) {\n          linkContent = slider.settings.buildPager(i);\n          slider.pagerEl.addClass('bx-custom-pager');\n        } else {\n          linkContent = i + 1;\n          slider.pagerEl.addClass('bx-default-pager');\n        }\n        // var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;\n        // add the markup to the string\n        pagerHtml += '<div class=\"bx-pager-item\"><a href=\"\" data-slide-index=\"' + i + '\" class=\"bx-pager-link\">' + linkContent + '</a></div>';\n      }\n      // populate the pager element with pager links\n      slider.pagerEl.html(pagerHtml);\n    };\n\n    /**\r\n     * Appends the pager to the controls element\r\n     */\n    var appendPager = function appendPager() {\n      if (!slider.settings.pagerCustom) {\n        // create the pager DOM element\n        slider.pagerEl = $('<div class=\"bx-pager\" />');\n        // if a pager selector was supplied, populate it with the pager\n        if (slider.settings.pagerSelector) {\n          $(slider.settings.pagerSelector).html(slider.pagerEl);\n          // if no pager selector was supplied, add it after the wrapper\n        } else {\n            slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);\n          }\n        // populate the pager\n        populatePager();\n      } else {\n        slider.pagerEl = $(slider.settings.pagerCustom);\n      }\n      // assign the pager click binding\n      slider.pagerEl.on('click touchend', 'a', clickPagerBind);\n    };\n\n    /**\r\n     * Appends prev / next controls to the controls element\r\n     */\n    var appendControls = function appendControls() {\n      slider.controls.next = $('<a class=\"bx-next\" href=\"\">' + slider.settings.nextText + '</a>');\n      slider.controls.prev = $('<a class=\"bx-prev\" href=\"\">' + slider.settings.prevText + '</a>');\n      // bind click actions to the controls\n      slider.controls.next.bind('click touchend', clickNextBind);\n      slider.controls.prev.bind('click touchend', clickPrevBind);\n      // if nextSelector was supplied, populate it\n      if (slider.settings.nextSelector) {\n        $(slider.settings.nextSelector).append(slider.controls.next);\n      }\n      // if prevSelector was supplied, populate it\n      if (slider.settings.prevSelector) {\n        $(slider.settings.prevSelector).append(slider.controls.prev);\n      }\n      // if no custom selectors were supplied\n      if (!slider.settings.nextSelector && !slider.settings.prevSelector) {\n        // add the controls to the DOM\n        slider.controls.directionEl = $('<div class=\"bx-controls-direction\" />');\n        // add the control elements to the directionEl\n        slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);\n        // slider.viewport.append(slider.controls.directionEl);\n        slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);\n      }\n    };\n\n    /**\r\n     * Appends start / stop auto controls to the controls element\r\n     */\n    var appendControlsAuto = function appendControlsAuto() {\n      slider.controls.start = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-start\" href=\"\">' + slider.settings.startText + '</a></div>');\n      slider.controls.stop = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-stop\" href=\"\">' + slider.settings.stopText + '</a></div>');\n      // add the controls to the DOM\n      slider.controls.autoEl = $('<div class=\"bx-controls-auto\" />');\n      // bind click actions to the controls\n      slider.controls.autoEl.on('click', '.bx-start', clickStartBind);\n      slider.controls.autoEl.on('click', '.bx-stop', clickStopBind);\n      // if autoControlsCombine, insert only the \"start\" control\n      if (slider.settings.autoControlsCombine) {\n        slider.controls.autoEl.append(slider.controls.start);\n        // if autoControlsCombine is false, insert both controls\n      } else {\n          slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);\n        }\n      // if auto controls selector was supplied, populate it with the controls\n      if (slider.settings.autoControlsSelector) {\n        $(slider.settings.autoControlsSelector).html(slider.controls.autoEl);\n        // if auto controls selector was not supplied, add it after the wrapper\n      } else {\n          slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);\n        }\n      // update the auto controls\n      updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');\n    };\n\n    /**\r\n     * Appends image captions to the DOM\r\n     */\n    var appendCaptions = function appendCaptions() {\n      // cycle through each child\n      slider.children.each(function (index) {\n        // get the image title attribute\n        var title = $(this).find('img:first').attr('title');\n        // append the caption\n        if (title !== undefined && ('' + title).length) {\n          $(this).append('<div class=\"bx-caption\"><span>' + title + '</span></div>');\n        }\n      });\n    };\n\n    /**\r\n     * Click next binding\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var clickNextBind = function clickNextBind(e) {\n      e.preventDefault();\n      if (slider.controls.el.hasClass('disabled')) {\n        return;\n      }\n      // if auto show is running, stop it\n      if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n        el.stopAuto();\n      }\n      el.goToNextSlide();\n    };\n\n    /**\r\n     * Click prev binding\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var clickPrevBind = function clickPrevBind(e) {\n      e.preventDefault();\n      if (slider.controls.el.hasClass('disabled')) {\n        return;\n      }\n      // if auto show is running, stop it\n      if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n        el.stopAuto();\n      }\n      el.goToPrevSlide();\n    };\n\n    /**\r\n     * Click start binding\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var clickStartBind = function clickStartBind(e) {\n      el.startAuto();\n      e.preventDefault();\n    };\n\n    /**\r\n     * Click stop binding\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var clickStopBind = function clickStopBind(e) {\n      el.stopAuto();\n      e.preventDefault();\n    };\n\n    /**\r\n     * Click pager binding\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var clickPagerBind = function clickPagerBind(e) {\n      var pagerLink, pagerIndex;\n      e.preventDefault();\n      if (slider.controls.el.hasClass('disabled')) {\n        return;\n      }\n      // if auto show is running, stop it\n      if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n        el.stopAuto();\n      }\n      pagerLink = $(e.currentTarget);\n      if (pagerLink.attr('data-slide-index') !== undefined) {\n        pagerIndex = parseInt(pagerLink.attr('data-slide-index'));\n        // if clicked pager link is not active, continue with the goToSlide call\n        if (pagerIndex !== slider.active.index) {\n          el.goToSlide(pagerIndex);\n        }\n      }\n    };\n\n    /**\r\n     * Updates the pager links with an active class\r\n     *\r\n     * @param slideIndex (int)\r\n     *  - index of slide to make active\r\n     */\n    var updatePagerActive = function updatePagerActive(slideIndex) {\n      // if \"short\" pager type\n      var len = slider.children.length; // nb of children\n      if (slider.settings.pagerType === 'short') {\n        if (slider.settings.maxSlides > 1) {\n          len = Math.ceil(slider.children.length / slider.settings.maxSlides);\n        }\n        slider.pagerEl.html(slideIndex + 1 + slider.settings.pagerShortSeparator + len);\n        return;\n      }\n      // remove all pager active classes\n      slider.pagerEl.find('a').removeClass('active');\n      // apply the active class for all pagers\n      slider.pagerEl.each(function (i, el) {\n        $(el).find('a').eq(slideIndex).addClass('active');\n      });\n    };\n\n    /**\r\n     * Performs needed actions after a slide transition\r\n     */\n    var updateAfterSlideTransition = function updateAfterSlideTransition() {\n      // if infinite loop is true\n      if (slider.settings.infiniteLoop) {\n        var position = '';\n        // first slide\n        if (slider.active.index === 0) {\n          // set the new position\n          position = slider.children.eq(0).position();\n          // carousel, last slide\n        } else if (slider.active.index === getPagerQty() - 1 && slider.carousel) {\n            position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();\n            // last slide\n          } else if (slider.active.index === slider.children.length - 1) {\n              position = slider.children.eq(slider.children.length - 1).position();\n            }\n        if (position) {\n          if (slider.settings.mode === 'horizontal') {\n            setPositionProperty(-position.left, 'reset', 0);\n          } else if (slider.settings.mode === 'vertical') {\n            setPositionProperty(-position.top, 'reset', 0);\n          }\n        }\n      }\n      // declare that the transition is complete\n      slider.working = false;\n      // onSlideAfter callback\n      slider.settings.onSlideAfter.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n    };\n\n    /**\r\n     * Updates the auto controls state (either active, or combined switch)\r\n     *\r\n     * @param state (string) \"start\", \"stop\"\r\n     *  - the new state of the auto show\r\n     */\n    var updateAutoControls = function updateAutoControls(state) {\n      // if autoControlsCombine is true, replace the current control with the new state\n      if (slider.settings.autoControlsCombine) {\n        slider.controls.autoEl.html(slider.controls[state]);\n        // if autoControlsCombine is false, apply the \"active\" class to the appropriate control\n      } else {\n          slider.controls.autoEl.find('a').removeClass('active');\n          slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');\n        }\n    };\n\n    /**\r\n     * Updates the direction controls (checks if either should be hidden)\r\n     */\n    var updateDirectionControls = function updateDirectionControls() {\n      if (getPagerQty() === 1) {\n        slider.controls.prev.addClass('disabled');\n        slider.controls.next.addClass('disabled');\n      } else if (!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd) {\n        // if first slide\n        if (slider.active.index === 0) {\n          slider.controls.prev.addClass('disabled');\n          slider.controls.next.removeClass('disabled');\n          // if last slide\n        } else if (slider.active.index === getPagerQty() - 1) {\n            slider.controls.next.addClass('disabled');\n            slider.controls.prev.removeClass('disabled');\n            // if any slide in the middle\n          } else {\n              slider.controls.prev.removeClass('disabled');\n              slider.controls.next.removeClass('disabled');\n            }\n      }\n    };\n    /* auto start and stop functions */\n    var windowFocusHandler = function windowFocusHandler() {\n      el.startAuto();\n    };\n    var windowBlurHandler = function windowBlurHandler() {\n      el.stopAuto();\n    };\n    /**\r\n     * Initializes the auto process\r\n     */\n    var initAuto = function initAuto() {\n      // if autoDelay was supplied, launch the auto show using a setTimeout() call\n      if (slider.settings.autoDelay > 0) {\n        var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);\n        // if autoDelay was not supplied, start the auto show normally\n      } else {\n          el.startAuto();\n\n          //add focus and blur events to ensure its running if timeout gets paused\n          $(window).focus(windowFocusHandler).blur(windowBlurHandler);\n        }\n      // if autoHover is requested\n      if (slider.settings.autoHover) {\n        // on el hover\n        el.hover(function () {\n          // if the auto show is currently playing (has an active interval)\n          if (slider.interval) {\n            // stop the auto show and pass true argument which will prevent control update\n            el.stopAuto(true);\n            // create a new autoPaused value which will be used by the relative \"mouseout\" event\n            slider.autoPaused = true;\n          }\n        }, function () {\n          // if the autoPaused value was created be the prior \"mouseover\" event\n          if (slider.autoPaused) {\n            // start the auto show and pass true argument which will prevent control update\n            el.startAuto(true);\n            // reset the autoPaused value\n            slider.autoPaused = null;\n          }\n        });\n      }\n    };\n\n    /**\r\n     * Initializes the ticker process\r\n     */\n    var initTicker = function initTicker() {\n      var startPosition = 0,\n          position,\n          transform,\n          value,\n          idx,\n          ratio,\n          property,\n          newSpeed,\n          totalDimens;\n      // if autoDirection is \"next\", append a clone of the entire slider\n      if (slider.settings.autoDirection === 'next') {\n        el.append(slider.children.clone().addClass('bx-clone'));\n        // if autoDirection is \"prev\", prepend a clone of the entire slider, and set the left position\n      } else {\n          el.prepend(slider.children.clone().addClass('bx-clone'));\n          position = slider.children.first().position();\n          startPosition = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n        }\n      setPositionProperty(startPosition, 'reset', 0);\n      // do not allow controls in ticker mode\n      slider.settings.pager = false;\n      slider.settings.controls = false;\n      slider.settings.autoControls = false;\n      // if autoHover is requested\n      if (slider.settings.tickerHover) {\n        if (slider.usingCSS) {\n          idx = slider.settings.mode === 'horizontal' ? 4 : 5;\n          slider.viewport.hover(function () {\n            transform = el.css('-' + slider.cssPrefix + '-transform');\n            value = parseFloat(transform.split(',')[idx]);\n            setPositionProperty(value, 'reset', 0);\n          }, function () {\n            totalDimens = 0;\n            slider.children.each(function (index) {\n              totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n            });\n            // calculate the speed ratio (used to determine the new speed to finish the paused animation)\n            ratio = slider.settings.speed / totalDimens;\n            // determine which property to use\n            property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\n            // calculate the new speed\n            newSpeed = ratio * (totalDimens - Math.abs(parseInt(value)));\n            tickerLoop(newSpeed);\n          });\n        } else {\n          // on el hover\n          slider.viewport.hover(function () {\n            el.stop();\n          }, function () {\n            // calculate the total width of children (used to calculate the speed ratio)\n            totalDimens = 0;\n            slider.children.each(function (index) {\n              totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n            });\n            // calculate the speed ratio (used to determine the new speed to finish the paused animation)\n            ratio = slider.settings.speed / totalDimens;\n            // determine which property to use\n            property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\n            // calculate the new speed\n            newSpeed = ratio * (totalDimens - Math.abs(parseInt(el.css(property))));\n            tickerLoop(newSpeed);\n          });\n        }\n      }\n      // start the ticker loop\n      tickerLoop();\n    };\n\n    /**\r\n     * Runs a continuous loop, news ticker-style\r\n     */\n    var tickerLoop = function tickerLoop(resumeSpeed) {\n      var speed = resumeSpeed ? resumeSpeed : slider.settings.speed,\n          position = { left: 0, top: 0 },\n          reset = { left: 0, top: 0 },\n          animateProperty,\n          resetValue,\n          params;\n\n      // if \"next\" animate left position to last child, then reset left to 0\n      if (slider.settings.autoDirection === 'next') {\n        position = el.find('.bx-clone').first().position();\n        // if \"prev\" animate left position to 0, then reset left to first non-clone child\n      } else {\n          reset = slider.children.first().position();\n        }\n      animateProperty = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n      resetValue = slider.settings.mode === 'horizontal' ? -reset.left : -reset.top;\n      params = { resetValue: resetValue };\n      setPositionProperty(animateProperty, 'ticker', speed, params);\n    };\n\n    /**\r\n     * Check if el is on screen\r\n     */\n    var isOnScreen = function isOnScreen(el) {\n      var win = $(window),\n          viewport = {\n        top: win.scrollTop(),\n        left: win.scrollLeft()\n      },\n          bounds = el.offset();\n\n      viewport.right = viewport.left + win.width();\n      viewport.bottom = viewport.top + win.height();\n      bounds.right = bounds.left + el.outerWidth();\n      bounds.bottom = bounds.top + el.outerHeight();\n\n      return !(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom);\n    };\n\n    /**\r\n     * Initializes keyboard events\r\n     */\n    var keyPress = function keyPress(e) {\n      var activeElementTag = document.activeElement.tagName.toLowerCase(),\n          tagFilters = 'input|textarea',\n          p = new RegExp(activeElementTag, ['i']),\n          result = p.exec(tagFilters);\n\n      if (result == null && isOnScreen(el)) {\n        if (e.keyCode === 39) {\n          clickNextBind(e);\n          return false;\n        } else if (e.keyCode === 37) {\n          clickPrevBind(e);\n          return false;\n        }\n      }\n    };\n\n    /**\r\n     * Initializes touch events\r\n     */\n    var initTouch = function initTouch() {\n      // initialize object to contain all touch values\n      slider.touch = {\n        start: { x: 0, y: 0 },\n        end: { x: 0, y: 0 }\n      };\n      slider.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);\n\n      //for browsers that have implemented pointer events and fire a click after\n      //every pointerup regardless of whether pointerup is on same screen location as pointerdown or not\n      slider.viewport.on('click', '.bxslider a', function (e) {\n        if (slider.viewport.hasClass('click-disabled')) {\n          e.preventDefault();\n          slider.viewport.removeClass('click-disabled');\n        }\n      });\n    };\n\n    /**\r\n     * Event handler for \"touchstart\"\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var onTouchStart = function onTouchStart(e) {\n      //disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls\n      slider.controls.el.addClass('disabled');\n\n      if (slider.working) {\n        e.preventDefault();\n        slider.controls.el.removeClass('disabled');\n      } else {\n        // record the original position when touch starts\n        slider.touch.originalPos = el.position();\n        var orig = e.originalEvent,\n            touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig];\n        // record the starting touch x, y coordinates\n        slider.touch.start.x = touchPoints[0].pageX;\n        slider.touch.start.y = touchPoints[0].pageY;\n\n        if (slider.viewport.get(0).setPointerCapture) {\n          slider.pointerId = orig.pointerId;\n          slider.viewport.get(0).setPointerCapture(slider.pointerId);\n        }\n        // bind a \"touchmove\" event to the viewport\n        slider.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);\n        // bind a \"touchend\" event to the viewport\n        slider.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);\n        slider.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);\n      }\n    };\n\n    /**\r\n     * Cancel Pointer for Windows Phone\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var onPointerCancel = function onPointerCancel(e) {\n      /* onPointerCancel handler is needed to deal with situations when a touchend\r\n      doesn't fire after a touchstart (this happens on windows phones only) */\n      setPositionProperty(slider.touch.originalPos.left, 'reset', 0);\n\n      //remove handlers\n      slider.controls.el.removeClass('disabled');\n      slider.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);\n      slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n      slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n      if (slider.viewport.get(0).releasePointerCapture) {\n        slider.viewport.get(0).releasePointerCapture(slider.pointerId);\n      }\n    };\n\n    /**\r\n     * Event handler for \"touchmove\"\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var onTouchMove = function onTouchMove(e) {\n      var orig = e.originalEvent,\n          touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig],\n\n      // if scrolling on y axis, do not prevent default\n      xMovement = Math.abs(touchPoints[0].pageX - slider.touch.start.x),\n          yMovement = Math.abs(touchPoints[0].pageY - slider.touch.start.y),\n          value = 0,\n          change = 0;\n\n      // x axis swipe\n      if (xMovement * 3 > yMovement && slider.settings.preventDefaultSwipeX) {\n        e.preventDefault();\n        // y axis swipe\n      } else if (yMovement * 3 > xMovement && slider.settings.preventDefaultSwipeY) {\n          e.preventDefault();\n        }\n      if (slider.settings.mode !== 'fade' && slider.settings.oneToOneTouch) {\n        // if horizontal, drag along x axis\n        if (slider.settings.mode === 'horizontal') {\n          change = touchPoints[0].pageX - slider.touch.start.x;\n          value = slider.touch.originalPos.left + change;\n          // if vertical, drag along y axis\n        } else {\n            change = touchPoints[0].pageY - slider.touch.start.y;\n            value = slider.touch.originalPos.top + change;\n          }\n        setPositionProperty(value, 'reset', 0);\n      }\n    };\n\n    /**\r\n     * Event handler for \"touchend\"\r\n     *\r\n     * @param e (event)\r\n     *  - DOM event object\r\n     */\n    var onTouchEnd = function onTouchEnd(e) {\n      slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n      //enable slider controls as soon as user stops interacing with slides\n      slider.controls.el.removeClass('disabled');\n      var orig = e.originalEvent,\n          touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig],\n          value = 0,\n          distance = 0;\n      // record end x, y positions\n      slider.touch.end.x = touchPoints[0].pageX;\n      slider.touch.end.y = touchPoints[0].pageY;\n      // if fade mode, check if absolute x distance clears the threshold\n      if (slider.settings.mode === 'fade') {\n        distance = Math.abs(slider.touch.start.x - slider.touch.end.x);\n        if (distance >= slider.settings.swipeThreshold) {\n          if (slider.touch.start.x > slider.touch.end.x) {\n            el.goToNextSlide();\n          } else {\n            el.goToPrevSlide();\n          }\n          el.stopAuto();\n        }\n        // not fade mode\n      } else {\n          // calculate distance and el's animate property\n          if (slider.settings.mode === 'horizontal') {\n            distance = slider.touch.end.x - slider.touch.start.x;\n            value = slider.touch.originalPos.left;\n          } else {\n            distance = slider.touch.end.y - slider.touch.start.y;\n            value = slider.touch.originalPos.top;\n          }\n          // if not infinite loop and first / last slide, do not attempt a slide transition\n          if (!slider.settings.infiniteLoop && (slider.active.index === 0 && distance > 0 || slider.active.last && distance < 0)) {\n            setPositionProperty(value, 'reset', 200);\n          } else {\n            // check if distance clears threshold\n            if (Math.abs(distance) >= slider.settings.swipeThreshold) {\n              if (distance < 0) {\n                el.goToNextSlide();\n              } else {\n                el.goToPrevSlide();\n              }\n              el.stopAuto();\n            } else {\n              // el.animate(property, 200);\n              setPositionProperty(value, 'reset', 200);\n            }\n          }\n        }\n      slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n      if (slider.viewport.get(0).releasePointerCapture) {\n        slider.viewport.get(0).releasePointerCapture(slider.pointerId);\n      }\n    };\n\n    /**\r\n     * Window resize event callback\r\n     */\n    var resizeWindow = function resizeWindow(e) {\n      // don't do anything if slider isn't initialized.\n      if (!slider.initialized) {\n        return;\n      }\n      // Delay if slider working.\n      if (slider.working) {\n        window.setTimeout(resizeWindow, 10);\n      } else {\n        // get the new window dimens (again, thank you IE)\n        var windowWidthNew = $(window).width(),\n            windowHeightNew = $(window).height();\n        // make sure that it is a true window resize\n        // *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements\n        // are resized. Can you just die already?*\n        if (windowWidth !== windowWidthNew || windowHeight !== windowHeightNew) {\n          // set the new window dimens\n          windowWidth = windowWidthNew;\n          windowHeight = windowHeightNew;\n          // update all dynamic elements\n          el.redrawSlider();\n          // Call user resize handler\n          slider.settings.onSliderResize.call(el, slider.active.index);\n        }\n      }\n    };\n\n    /**\r\n     * Adds an aria-hidden=true attribute to each element\r\n     *\r\n     * @param startVisibleIndex (int)\r\n     *  - the first visible element's index\r\n     */\n    var applyAriaHiddenAttributes = function applyAriaHiddenAttributes(startVisibleIndex) {\n      var numberOfSlidesShowing = getNumberSlidesShowing();\n      // only apply attributes if the setting is enabled and not in ticker mode\n      if (slider.settings.ariaHidden && !slider.settings.ticker) {\n        // add aria-hidden=true to all elements\n        slider.children.attr('aria-hidden', 'true');\n        // get the visible elements and change to aria-hidden=false\n        slider.children.slice(startVisibleIndex, startVisibleIndex + numberOfSlidesShowing).attr('aria-hidden', 'false');\n      }\n    };\n\n    /**\r\n     * Returns index according to present page range\r\n     *\r\n     * @param slideOndex (int)\r\n     *  - the desired slide index\r\n     */\n    var setSlideIndex = function setSlideIndex(slideIndex) {\n      if (slideIndex < 0) {\n        if (slider.settings.infiniteLoop) {\n          return getPagerQty() - 1;\n        } else {\n          //we don't go to undefined slides\n          return slider.active.index;\n        }\n        // if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)\n      } else if (slideIndex >= getPagerQty()) {\n          if (slider.settings.infiniteLoop) {\n            return 0;\n          } else {\n            //we don't move to undefined pages\n            return slider.active.index;\n          }\n          // set active index to requested slide\n        } else {\n            return slideIndex;\n          }\n    };\n\n    /**\r\n     * ===================================================================================\r\n     * = PUBLIC FUNCTIONS\r\n     * ===================================================================================\r\n     */\n\n    /**\r\n     * Performs slide transition to the specified slide\r\n     *\r\n     * @param slideIndex (int)\r\n     *  - the destination slide's index (zero-based)\r\n     *\r\n     * @param direction (string)\r\n     *  - INTERNAL USE ONLY - the direction of travel (\"prev\" / \"next\")\r\n     */\n    el.goToSlide = function (slideIndex, direction) {\n      // onSlideBefore, onSlideNext, onSlidePrev callbacks\n      // Allow transition canceling based on returned value\n      var performTransition = true,\n          moveBy = 0,\n          position = { left: 0, top: 0 },\n          lastChild = null,\n          lastShowingIndex,\n          eq,\n          value,\n          requestEl;\n      // store the old index\n      slider.oldIndex = slider.active.index;\n      //set new index\n      slider.active.index = setSlideIndex(slideIndex);\n\n      // if plugin is currently in motion, ignore request\n      if (slider.working || slider.active.index === slider.oldIndex) {\n        return;\n      }\n      // declare that plugin is in motion\n      slider.working = true;\n\n      performTransition = slider.settings.onSlideBefore.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n\n      // If transitions canceled, reset and return\n      if (typeof performTransition !== 'undefined' && !performTransition) {\n        slider.active.index = slider.oldIndex; // restore old index\n        slider.working = false; // is not in motion\n        return;\n      }\n\n      if (direction === 'next') {\n        // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n        if (!slider.settings.onSlideNext.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\n          performTransition = false;\n        }\n      } else if (direction === 'prev') {\n        // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n        if (!slider.settings.onSlidePrev.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\n          performTransition = false;\n        }\n      }\n\n      // check if last slide\n      slider.active.last = slider.active.index >= getPagerQty() - 1;\n      // update the pager with active class\n      if (slider.settings.pager || slider.settings.pagerCustom) {\n        updatePagerActive(slider.active.index);\n      }\n      // // check for direction control update\n      if (slider.settings.controls) {\n        updateDirectionControls();\n      }\n      // if slider is set to mode: \"fade\"\n      if (slider.settings.mode === 'fade') {\n        // if adaptiveHeight is true and next height is different from current height, animate to the new height\n        if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\n          slider.viewport.animate({ height: getViewportHeight() }, slider.settings.adaptiveHeightSpeed);\n        }\n        // fade out the visible child and reset its z-index value\n        slider.children.filter(':visible').fadeOut(slider.settings.speed).css({ zIndex: 0 });\n        // fade in the newly requested slide\n        slider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex + 1).fadeIn(slider.settings.speed, function () {\n          $(this).css('zIndex', slider.settings.slideZIndex);\n          updateAfterSlideTransition();\n        });\n        // slider mode is not \"fade\"\n      } else {\n          // if adaptiveHeight is true and next height is different from current height, animate to the new height\n          if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\n            slider.viewport.animate({ height: getViewportHeight() }, slider.settings.adaptiveHeightSpeed);\n          }\n          // if carousel and not infinite loop\n          if (!slider.settings.infiniteLoop && slider.carousel && slider.active.last) {\n            if (slider.settings.mode === 'horizontal') {\n              // get the last child position\n              lastChild = slider.children.eq(slider.children.length - 1);\n              position = lastChild.position();\n              // calculate the position of the last slide\n              moveBy = slider.viewport.width() - lastChild.outerWidth();\n            } else {\n              // get last showing index position\n              lastShowingIndex = slider.children.length - slider.settings.minSlides;\n              position = slider.children.eq(lastShowingIndex).position();\n            }\n            // horizontal carousel, going previous while on first slide (infiniteLoop mode)\n          } else if (slider.carousel && slider.active.last && direction === 'prev') {\n              // get the last child position\n              eq = slider.settings.moveSlides === 1 ? slider.settings.maxSlides - getMoveBy() : (getPagerQty() - 1) * getMoveBy() - (slider.children.length - slider.settings.maxSlides);\n              lastChild = el.children('.bx-clone').eq(eq);\n              position = lastChild.position();\n              // if infinite loop and \"Next\" is clicked on the last slide\n            } else if (direction === 'next' && slider.active.index === 0) {\n                // get the last clone position\n                position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();\n                slider.active.last = false;\n                // normal non-zero requests\n              } else if (slideIndex >= 0) {\n                  //parseInt is applied to allow floats for slides/page\n                  requestEl = slideIndex * parseInt(getMoveBy());\n                  position = slider.children.eq(requestEl).position();\n                }\n\n          /* If the position doesn't exist\r\n           * (e.g. if you destroy the slider on a next click),\r\n           * it doesn't throw an error.\r\n           */\n          if (typeof position !== 'undefined') {\n            value = slider.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;\n            // plugin values to be animated\n            setPositionProperty(value, 'slide', slider.settings.speed);\n          }\n          slider.working = false;\n        }\n      if (slider.settings.ariaHidden) {\n        applyAriaHiddenAttributes(slider.active.index * getMoveBy());\n      }\n    };\n\n    /**\r\n     * Transitions to the next slide in the show\r\n     */\n    el.goToNextSlide = function () {\n      // if infiniteLoop is false and last page is showing, disregard call\n      if (!slider.settings.infiniteLoop && slider.active.last) {\n        return;\n      }\n      if (slider.working == true) {\n        return;\n      }\n      var pagerIndex = parseInt(slider.active.index) + 1;\n      el.goToSlide(pagerIndex, 'next');\n    };\n\n    /**\r\n     * Transitions to the prev slide in the show\r\n     */\n    el.goToPrevSlide = function () {\n      // if infiniteLoop is false and last page is showing, disregard call\n      if (!slider.settings.infiniteLoop && slider.active.index === 0) {\n        return;\n      }\n      if (slider.working == true) {\n        return;\n      }\n      var pagerIndex = parseInt(slider.active.index) - 1;\n      el.goToSlide(pagerIndex, 'prev');\n    };\n\n    /**\r\n     * Starts the auto show\r\n     *\r\n     * @param preventControlUpdate (boolean)\r\n     *  - if true, auto controls state will not be updated\r\n     */\n    el.startAuto = function (preventControlUpdate) {\n      // if an interval already exists, disregard call\n      if (slider.interval) {\n        return;\n      }\n      // create an interval\n      slider.interval = setInterval(function () {\n        if (slider.settings.autoDirection === 'next') {\n          el.goToNextSlide();\n        } else {\n          el.goToPrevSlide();\n        }\n      }, slider.settings.pause);\n      //allback for when the auto rotate status changes\n      slider.settings.onAutoChange.call(el, true);\n      // if auto controls are displayed and preventControlUpdate is not true\n      if (slider.settings.autoControls && preventControlUpdate !== true) {\n        updateAutoControls('stop');\n      }\n    };\n\n    /**\r\n     * Stops the auto show\r\n     *\r\n     * @param preventControlUpdate (boolean)\r\n     *  - if true, auto controls state will not be updated\r\n     */\n    el.stopAuto = function (preventControlUpdate) {\n      // if no interval exists, disregard call\n      if (!slider.interval) {\n        return;\n      }\n      // clear the interval\n      clearInterval(slider.interval);\n      slider.interval = null;\n      //allback for when the auto rotate status changes\n      slider.settings.onAutoChange.call(el, false);\n      // if auto controls are displayed and preventControlUpdate is not true\n      if (slider.settings.autoControls && preventControlUpdate !== true) {\n        updateAutoControls('start');\n      }\n    };\n\n    /**\r\n     * Returns current slide index (zero-based)\r\n     */\n    el.getCurrentSlide = function () {\n      return slider.active.index;\n    };\n\n    /**\r\n     * Returns current slide element\r\n     */\n    el.getCurrentSlideElement = function () {\n      return slider.children.eq(slider.active.index);\n    };\n\n    /**\r\n     * Returns a slide element\r\n     * @param index (int)\r\n     *  - The index (zero-based) of the element you want returned.\r\n     */\n    el.getSlideElement = function (index) {\n      return slider.children.eq(index);\n    };\n\n    /**\r\n     * Returns number of slides in show\r\n     */\n    el.getSlideCount = function () {\n      return slider.children.length;\n    };\n\n    /**\r\n     * Return slider.working variable\r\n     */\n    el.isWorking = function () {\n      return slider.working;\n    };\n\n    /**\r\n     * Update all dynamic slider elements\r\n     */\n    el.redrawSlider = function () {\n      // resize all children in ratio to new screen size\n      slider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());\n      // adjust the height\n      slider.viewport.css('height', getViewportHeight());\n      // update the slide position\n      if (!slider.settings.ticker) {\n        setSlidePosition();\n      }\n      // if active.last was true before the screen resize, we want\n      // to keep it last no matter what screen size we end on\n      if (slider.active.last) {\n        slider.active.index = getPagerQty() - 1;\n      }\n      // if the active index (page) no longer exists due to the resize, simply set the index as last\n      if (slider.active.index >= getPagerQty()) {\n        slider.active.last = true;\n      }\n      // if a pager is being displayed and a custom pager is not being used, update it\n      if (slider.settings.pager && !slider.settings.pagerCustom) {\n        populatePager();\n        updatePagerActive(slider.active.index);\n      }\n      if (slider.settings.ariaHidden) {\n        applyAriaHiddenAttributes(slider.active.index * getMoveBy());\n      }\n    };\n\n    /**\r\n     * Destroy the current instance of the slider (revert everything back to original state)\r\n     */\n    el.destroySlider = function () {\n      // don't do anything if slider has already been destroyed\n      if (!slider.initialized) {\n        return;\n      }\n      slider.initialized = false;\n      $('.bx-clone', this).remove();\n      slider.children.each(function () {\n        if ($(this).data('origStyle') !== undefined) {\n          $(this).attr('style', $(this).data('origStyle'));\n        } else {\n          $(this).removeAttr('style');\n        }\n      });\n      if ($(this).data('origStyle') !== undefined) {\n        this.attr('style', $(this).data('origStyle'));\n      } else {\n        $(this).removeAttr('style');\n      }\n      $(this).unwrap().unwrap();\n      if (slider.controls.el) {\n        slider.controls.el.remove();\n      }\n      if (slider.controls.next) {\n        slider.controls.next.remove();\n      }\n      if (slider.controls.prev) {\n        slider.controls.prev.remove();\n      }\n      if (slider.pagerEl && slider.settings.controls && !slider.settings.pagerCustom) {\n        slider.pagerEl.remove();\n      }\n      $('.bx-caption', this).remove();\n      if (slider.controls.autoEl) {\n        slider.controls.autoEl.remove();\n      }\n      clearInterval(slider.interval);\n      if (slider.settings.responsive) {\n        $(window).unbind('resize', resizeWindow);\n      }\n      if (slider.settings.keyboardEnabled) {\n        $(document).unbind('keydown', keyPress);\n      }\n      //remove self reference in data\n      $(this).removeData('bxSlider');\n      // remove global window handlers\n      $(window).off('blur', windowBlurHandler).off('focus', windowFocusHandler);\n    };\n\n    /**\r\n     * Reload the slider (revert all DOM changes, and re-initialize)\r\n     */\n    el.reloadSlider = function (settings) {\n      if (settings !== undefined) {\n        options = settings;\n      }\n      el.destroySlider();\n      init();\n      //store reference to self in order to access public functions later\n      $(el).data('bxSlider', this);\n    };\n\n    init();\n\n    $(el).data('bxSlider', this);\n\n    // returns the current jQuery object\n    return this;\n  };\n})(jQuery);\n\n/***/ }),\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// import {LoginBabel} from './login/login-babel.js';\n\n// new LoginBabel().$inject('#app');\n\n\n__webpack_require__(3);\n\n__webpack_require__(0);\n\n$(function () {\n    $('.bxslider').bxSlider();\n    $('.tab-item').click(function () {\n        $(this).addClass(\"active\").siblings().removeClass(\"active\"); //切换选中的按钮高亮状态\n        var index = $(this).index('.tab-item'); //获取被按下按钮的索引值，需要注意index是从0开始的\n        $(\".card-tab-cont\").eq(index).show().siblings().hide();\n    });\n});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// static/js/course.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8a78be20f85ddde7b936","import {pop} from './prompt'\r\nglobal.pop=pop\r\n// 导航\r\nvar timer = null;\r\nvar loginInfo = $('.js-login-info');\r\nvar tipsUser = $('.js-tips-user');\r\nloginInfo.on('mouseenter', function () {\r\n    clearTimeout(timer);\r\n    tipsUser.show();\r\n    $.ajax({\r\n        url: '/api/plan/info',\r\n        data: {},\r\n        success: function(json) {\r\n            if (json && json.plan) {\r\n                var plan = json.plan;\r\n                var today_complete_rate = plan.today_complete_rate;\r\n                $('.circle circle[stroke-dasharray]')\r\n                    .attr('stroke-dasharray', (today_complete_rate * 2) + ' ' + (200 - today_complete_rate * 2));\r\n                $('.circle span').html(today_complete_rate + '%');\r\n            }\r\n        },\r\n    });\r\n});\r\nloginInfo.on('mouseleave', function () {\r\n    timer = setTimeout(function () {\r\n        tipsUser.hide();\r\n    }, 300);\r\n});\r\n\r\ntipsUser.on('mouseenter', function () {\r\n    clearTimeout(timer);\r\n});\r\n\r\ntipsUser.on('mouseleave', function () {\r\n    timer = setTimeout(function () {\r\n        tipsUser.hide();\r\n    }, 300);\r\n});\r\n\r\nvar btnSoso = $('.page-header__search .butn-soso');\r\nbtnSoso.on('click', function() {\r\n    // console.info(\"RUN\");\r\n    var soso = $('.page-header__search input').val();\r\n    if (soso && soso.length > 0) {\r\n        window.open('/search?keywords=' + soso, '_blank');\r\n        $('.page-header__search input').val('')\r\n        // console.info(soso);\r\n    }\r\n});\r\n$(\".page-header__search input\").keyup(()=>{\r\n    $(document).keypress(function(e) {\r\n        // 回车键事件\r\n        if(e.which == 13) {\r\n            var soso = $('.page-header__search input').val();\r\n            if (soso && soso.length > 0) {\r\n                window.open('/search?keywords=' + soso, '_blank');\r\n                // console.info(soso);\r\n            }\r\n        }\r\n    });\r\n});\r\nif(location.hostname=='localhost'){\r\n    $.ajaxSetup({\r\n        beforeSend: function (xhr,settings) {\r\n            xhr.setRequestHeader(\"Authorization\",\"Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjU0MDQ0MDQxZDA0M2RjMDgyYWJjNDA4OTg2OTlmZjc5ZjFmNzA0ZDgxNzEwNGYwYjVmYmYzY2ZjZjhmOWM4MTdiMzBhYjRiOWNmMTk3NDUyIn0.eyJhdWQiOiI2IiwianRpIjoiNTQwNDQwNDFkMDQzZGMwODJhYmM0MDg5ODY5OWZmNzlmMWY3MDRkODE3MTA0ZjBiNWZiZjNjZmNmOGY5YzgxN2IzMGFiNGI5Y2YxOTc0NTIiLCJpYXQiOjE1MjA2NzcxMDgsIm5iZiI6MTUyMDY3NzEwOCwiZXhwIjoxNTUyMjEzMTA4LCJzdWIiOiI4Iiwic2NvcGVzIjpbXX0.3irFbm_3KpOt6F4RsqJBsNH6NnvagJqLbRX3gPl_8uCJySMYpBBvDTXtMTmNqxTg02qviGTkw2gQw0e366keWAwP9ShKHfZQlS3uOINUzNBciB5BUFwP7PdFpgyPXVs5aCSU48Bmwb-QAZEv2rrX5CYGF0cxYjvDRjFWrGJwSiED9lxRva78057ioFicMeGsdVZjacqjzHzEi4EQHbaYt3KgT6z3EucFXcxk5ZyB9wlaXtdfrJ1JlPA4rv4bN-m6AYUVXOFy_XKLUU2_13xYIL3a0qVCL6_xMQxIueHvdi-46gwvTIkKfmbJSSpOcfuuUp3SG0i7YA4d5XArXuGRKO4iQ8aFQ0KBh8ot5n5MfdSVK9ZpA5-Ym-5O1NSbcnxDHYWj2XGzwqoSQrLGP9R-ijX0eITN7rcGfnIEgHYTwgIya8O7Rd6qqvQ-QCgX5PuxSSwlvBKpf49ENJxrX_CQY0d8Fh0R6zB5orsEzR6wQhOhzTi0OJuTgRq6V9Qc91PGBZVJKwE3Xxip3Mcf3wxTKEKgAdBb-I5cSbVgeZJN4eIC5ik0ASLrSaroQyMLe9xT7OOCnm1vA-A6iEWJcx7NIzsrfhEtCgSDs11pnQr70ltgLSdYoWi8NwSXpo37EP4io8ozRCC2qnuE3TlfqMzgJ14AlgXmipySWhhVrhuKtzw\");\r\n            settings.url = \"http://wxjy-mingyang.mion.cn\" + settings.url;\r\n        }\r\n    })\r\n}else{\r\n    $.ajaxSetup({\r\n        beforeSend:function (xhr) {\r\n            window.WXJY = WXJY || {};\r\n            if(typeof WXJY.csrfToken !=='undefined'){\r\n                xhr.setRequestHeader(\"X-CSRF-TOKEN\", WXJY.csrfToken);\r\n            }\r\n        },\r\n    })\r\n}\r\n$.ajaxSetup({\r\n    statusCode: {\r\n        200:function (mess) {\r\n          if(!mess.code==0){\r\n              pop(mess.message,'#fa8c16')\r\n          }\r\n        },\r\n        401: function () {\r\n            window.location.href = '/login'\r\n        },\r\n        500: function () {\r\n            pop('网络异常，请稍后再试','red')\r\n        }\r\n    },\r\n    error: function (mess) {\r\n        if (mess.error == 'Unauthenticated.') {\r\n            window.location.href = '/login'\r\n        }\r\n    },\r\n    withCredentials: true\r\n});\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/header.js","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","//提示框动画\r\nfunction pop(txt, color) {\r\n    if(!$('.popprompt')[0]){\r\n        $(`<div class=\"popprompt\">看什么看，做题</div>`).appendTo('body')\r\n    }\r\n    let bg = color ? color : '#00e290'\r\n    $('.popprompt').text('').text(txt).css('background', bg).removeClass('off').addClass('on')\r\n    setTimeout(() => {\r\n        $('.popprompt').removeClass('on').addClass('off')\r\n    }, 2000)\r\n}\r\n\r\nexport {pop}\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/prompt.js","/**\r\n * bxSlider v4.2.12\r\n * Copyright 2013-2015 Steven Wanderski\r\n * Written while drinking Belgian ales and listening to jazz\r\n * Licensed under MIT (http://opensource.org/licenses/MIT)\r\n */\r\n\r\n;(function($) {\r\n  \r\n    var defaults = {\r\n  \r\n      // GENERAL\r\n      mode: 'horizontal',\r\n      slideSelector: '',\r\n      infiniteLoop: true,\r\n      hideControlOnEnd: false,\r\n      speed: 800,\r\n      easing: null,\r\n      slideMargin: 0,\r\n      startSlide: 0,\r\n      randomStart: false,\r\n      captions: false,\r\n      ticker: false,\r\n      tickerHover: false,\r\n      adaptiveHeight: false,\r\n      adaptiveHeightSpeed: 800,\r\n      video: false,\r\n      useCSS: true,\r\n      preloadImages: 'visible',\r\n      responsive: true,\r\n      slideZIndex: 50,\r\n      wrapperClass: 'bx-wrapper',\r\n  \r\n      // TOUCH\r\n      touchEnabled: true,\r\n      swipeThreshold: 50,\r\n      oneToOneTouch: true,\r\n      preventDefaultSwipeX: true,\r\n      preventDefaultSwipeY: false,\r\n  \r\n      // ACCESSIBILITY\r\n      ariaLive: true,\r\n      ariaHidden: true,\r\n  \r\n      // KEYBOARD\r\n      keyboardEnabled: false,\r\n  \r\n      // PAGER\r\n      pager: true,\r\n      pagerType: 'full',\r\n      pagerShortSeparator: ' / ',\r\n      pagerSelector: null,\r\n      buildPager: null,\r\n      pagerCustom: null,\r\n  \r\n      // CONTROLS\r\n      controls: true,\r\n      nextText: 'Next',\r\n      prevText: 'Prev',\r\n      nextSelector: null,\r\n      prevSelector: null,\r\n      autoControls: false,\r\n      startText: 'Start',\r\n      stopText: 'Stop',\r\n      autoControlsCombine: false,\r\n      autoControlsSelector: null,\r\n  \r\n      // AUTO\r\n      auto: true,\r\n      pause: 4000,\r\n      autoStart: true,\r\n      autoDirection: 'next',\r\n      stopAutoOnClick: false,\r\n      autoHover: true,\r\n      autoDelay: 0,\r\n      autoSlideForOnePage: false,\r\n  \r\n      // CAROUSEL\r\n      minSlides: 1,\r\n      maxSlides: 1,\r\n      moveSlides: 0,\r\n      slideWidth: 0,\r\n      shrinkItems: false,\r\n  \r\n      // CALLBACKS\r\n      onSliderLoad: function() { return true; },\r\n      onSlideBefore: function() { return true; },\r\n      onSlideAfter: function() { return true; },\r\n      onSlideNext: function() { return true; },\r\n      onSlidePrev: function() { return true; },\r\n      onSliderResize: function() { return true; },\r\n    onAutoChange: function() { return true; } //calls when auto slides starts and stops\r\n    };\r\n  \r\n    $.fn.bxSlider = function(options) {\r\n  \r\n      if (this.length === 0) {\r\n        return this;\r\n      }\r\n  \r\n      // support multiple elements\r\n      if (this.length > 1) {\r\n        this.each(function() {\r\n          $(this).bxSlider(options);\r\n        });\r\n        return this;\r\n      }\r\n  \r\n      // create a namespace to be used throughout the plugin\r\n      var slider = {},\r\n      // set a reference to our slider element\r\n      el = this,\r\n      // get the original window dimens (thanks a lot IE)\r\n      windowWidth = $(window).width(),\r\n      windowHeight = $(window).height();\r\n  \r\n      // Return if slider is already initialized\r\n      if ($(el).data('bxSlider')) { return; }\r\n  \r\n      /**\r\n       * ===================================================================================\r\n       * = PRIVATE FUNCTIONS\r\n       * ===================================================================================\r\n       */\r\n  \r\n      /**\r\n       * Initializes namespace settings to be used throughout plugin\r\n       */\r\n      var init = function() {\r\n        // Return if slider is already initialized\r\n        if ($(el).data('bxSlider')) { return; }\r\n        // merge user-supplied options with the defaults\r\n        slider.settings = $.extend({}, defaults, options);\r\n        // parse slideWidth setting\r\n        slider.settings.slideWidth = parseInt(slider.settings.slideWidth);\r\n        // store the original children\r\n        slider.children = el.children(slider.settings.slideSelector);\r\n        // check if actual number of slides is less than minSlides / maxSlides\r\n        if (slider.children.length < slider.settings.minSlides) { slider.settings.minSlides = slider.children.length; }\r\n        if (slider.children.length < slider.settings.maxSlides) { slider.settings.maxSlides = slider.children.length; }\r\n        // if random start, set the startSlide setting to random number\r\n        if (slider.settings.randomStart) { slider.settings.startSlide = Math.floor(Math.random() * slider.children.length); }\r\n        // store active slide information\r\n        slider.active = { index: slider.settings.startSlide };\r\n        // store if the slider is in carousel mode (displaying / moving multiple slides)\r\n        slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1 ? true : false;\r\n        // if carousel, force preloadImages = 'all'\r\n        if (slider.carousel) { slider.settings.preloadImages = 'all'; }\r\n        // calculate the min / max width thresholds based on min / max number of slides\r\n        // used to setup and update carousel slides dimensions\r\n        slider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);\r\n        slider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);\r\n        // store the current state of the slider (if currently animating, working is true)\r\n        slider.working = false;\r\n        // initialize the controls object\r\n        slider.controls = {};\r\n        // initialize an auto interval\r\n        slider.interval = null;\r\n        // determine which property to use for transitions\r\n        slider.animProp = slider.settings.mode === 'vertical' ? 'top' : 'left';\r\n        // determine if hardware acceleration can be used\r\n        slider.usingCSS = slider.settings.useCSS && slider.settings.mode !== 'fade' && (function() {\r\n          // create our test div element\r\n          var div = document.createElement('div'),\r\n          // css transition properties\r\n          props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];\r\n          // test for each property\r\n          for (var i = 0; i < props.length; i++) {\r\n            if (div.style[props[i]] !== undefined) {\r\n              slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();\r\n              slider.animProp = '-' + slider.cssPrefix + '-transform';\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }());\r\n        // if vertical mode always make maxSlides and minSlides equal\r\n        if (slider.settings.mode === 'vertical') { slider.settings.maxSlides = slider.settings.minSlides; }\r\n        // save original style data\r\n        el.data('origStyle', el.attr('style'));\r\n        el.children(slider.settings.slideSelector).each(function() {\r\n          $(this).data('origStyle', $(this).attr('style'));\r\n        });\r\n  \r\n        // perform all DOM / CSS modifications\r\n        setup();\r\n      };\r\n  \r\n      /**\r\n       * Performs all DOM and CSS modifications\r\n       */\r\n      var setup = function() {\r\n        var preloadSelector = slider.children.eq(slider.settings.startSlide); // set the default preload selector (visible)\r\n  \r\n        // wrap el in a wrapper\r\n        el.wrap('<div class=\"' + slider.settings.wrapperClass + '\"><div class=\"bx-viewport\"></div></div>');\r\n        // store a namespace reference to .bx-viewport\r\n        slider.viewport = el.parent();\r\n  \r\n        // add aria-live if the setting is enabled and ticker mode is disabled\r\n        if (slider.settings.ariaLive && !slider.settings.ticker) {\r\n          slider.viewport.attr('aria-live', 'polite');\r\n        }\r\n        // add a loading div to display while images are loading\r\n        slider.loader = $('<div class=\"bx-loading\" />');\r\n        slider.viewport.prepend(slider.loader);\r\n        // set el to a massive width, to hold any needed slides\r\n        // also strip any margin and padding from el\r\n        el.css({\r\n          width: slider.settings.mode === 'horizontal' ? (slider.children.length * 1000 + 215) + '%' : 'auto',\r\n          position: 'relative'\r\n        });\r\n        // if using CSS, add the easing property\r\n        if (slider.usingCSS && slider.settings.easing) {\r\n          el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);\r\n        // if not using CSS and no easing value was supplied, use the default JS animation easing (swing)\r\n        } else if (!slider.settings.easing) {\r\n          slider.settings.easing = 'swing';\r\n        }\r\n        // make modifications to the viewport (.bx-viewport)\r\n        slider.viewport.css({\r\n          width: '100%',\r\n          overflow: 'hidden',\r\n          position: 'relative'\r\n        });\r\n        slider.viewport.parent().css({\r\n          maxWidth: getViewportMaxWidth()\r\n        });\r\n        // apply css to all slider children\r\n        slider.children.css({\r\n          // the float attribute is a reserved word in compressors like YUI compressor and need to be quoted #48\r\n          'float': slider.settings.mode === 'horizontal' ? 'left' : 'none',\r\n          listStyle: 'none',\r\n          position: 'relative'\r\n        });\r\n        // apply the calculated width after the float is applied to prevent scrollbar interference\r\n        slider.children.css('width', getSlideWidth());\r\n        // if slideMargin is supplied, add the css\r\n        if (slider.settings.mode === 'horizontal' && slider.settings.slideMargin > 0) { slider.children.css('marginRight', slider.settings.slideMargin); }\r\n        if (slider.settings.mode === 'vertical' && slider.settings.slideMargin > 0) { slider.children.css('marginBottom', slider.settings.slideMargin); }\r\n        // if \"fade\" mode, add positioning and z-index CSS\r\n        if (slider.settings.mode === 'fade') {\r\n          slider.children.css({\r\n            position: 'absolute',\r\n            zIndex: 0,\r\n            display: 'none'\r\n          });\r\n          // prepare the z-index on the showing element\r\n          slider.children.eq(slider.settings.startSlide).css({zIndex: slider.settings.slideZIndex, display: 'block'});\r\n        }\r\n        // create an element to contain all slider controls (pager, start / stop, etc)\r\n        slider.controls.el = $('<div class=\"bx-controls\" />');\r\n        // if captions are requested, add them\r\n        if (slider.settings.captions) { appendCaptions(); }\r\n        // check if startSlide is last slide\r\n        slider.active.last = slider.settings.startSlide === getPagerQty() - 1;\r\n        // if video is true, set up the fitVids plugin\r\n        if (slider.settings.video) { el.fitVids(); }\r\n        if (slider.settings.preloadImages === 'all' || slider.settings.ticker) { preloadSelector = slider.children; }\r\n        // only check for control addition if not in \"ticker\" mode\r\n        if (!slider.settings.ticker) {\r\n          // if controls are requested, add them\r\n          if (slider.settings.controls) { appendControls(); }\r\n          // if auto is true, and auto controls are requested, add them\r\n          if (slider.settings.auto && slider.settings.autoControls) { appendControlsAuto(); }\r\n          // if pager is requested, add it\r\n          if (slider.settings.pager) { appendPager(); }\r\n          // if any control option is requested, add the controls wrapper\r\n          if (slider.settings.controls || slider.settings.autoControls || slider.settings.pager) { slider.viewport.after(slider.controls.el); }\r\n        // if ticker mode, do not allow a pager\r\n        } else {\r\n          slider.settings.pager = false;\r\n        }\r\n        loadElements(preloadSelector, start);\r\n      };\r\n  \r\n      var loadElements = function(selector, callback) {\r\n        var total = selector.find('img:not([src=\"\"]), iframe').length,\r\n        count = 0;\r\n        if (total === 0) {\r\n          callback();\r\n          return;\r\n        }\r\n        selector.find('img:not([src=\"\"]), iframe').each(function() {\r\n          $(this).one('load error', function() {\r\n            if (++count === total) { callback(); }\r\n          }).each(function() {\r\n            if (this.complete || this.src == '') { $(this).trigger('load'); }\r\n          });\r\n        });\r\n      };\r\n  \r\n      /**\r\n       * Start the slider\r\n       */\r\n      var start = function() {\r\n        // if infinite loop, prepare additional slides\r\n        if (slider.settings.infiniteLoop && slider.settings.mode !== 'fade' && !slider.settings.ticker) {\r\n          var slice    = slider.settings.mode === 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides,\r\n          sliceAppend  = slider.children.slice(0, slice).clone(true).addClass('bx-clone'),\r\n          slicePrepend = slider.children.slice(-slice).clone(true).addClass('bx-clone');\r\n          if (slider.settings.ariaHidden) {\r\n            sliceAppend.attr('aria-hidden', true);\r\n            slicePrepend.attr('aria-hidden', true);\r\n          }\r\n          el.append(sliceAppend).prepend(slicePrepend);\r\n        }\r\n        // remove the loading DOM element\r\n        slider.loader.remove();\r\n        // set the left / top position of \"el\"\r\n        setSlidePosition();\r\n        // if \"vertical\" mode, always use adaptiveHeight to prevent odd behavior\r\n        if (slider.settings.mode === 'vertical') { slider.settings.adaptiveHeight = true; }\r\n        // set the viewport height\r\n        slider.viewport.height(getViewportHeight());\r\n        // make sure everything is positioned just right (same as a window resize)\r\n        el.redrawSlider();\r\n        // onSliderLoad callback\r\n        slider.settings.onSliderLoad.call(el, slider.active.index);\r\n        // slider has been fully initialized\r\n        slider.initialized = true;\r\n        // bind the resize call to the window\r\n        if (slider.settings.responsive) { $(window).bind('resize', resizeWindow); }\r\n        // if auto is true and has more than 1 page, start the show\r\n        if (slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)) { initAuto(); }\r\n        // if ticker is true, start the ticker\r\n        if (slider.settings.ticker) { initTicker(); }\r\n        // if pager is requested, make the appropriate pager link active\r\n        if (slider.settings.pager) { updatePagerActive(slider.settings.startSlide); }\r\n        // check for any updates to the controls (like hideControlOnEnd updates)\r\n        if (slider.settings.controls) { updateDirectionControls(); }\r\n        // if touchEnabled is true, setup the touch events\r\n        if (slider.settings.touchEnabled && !slider.settings.ticker) { initTouch(); }\r\n        // if keyboardEnabled is true, setup the keyboard events\r\n        if (slider.settings.keyboardEnabled && !slider.settings.ticker) {\r\n          $(document).keydown(keyPress);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value\r\n       */\r\n      var getViewportHeight = function() {\r\n        var height = 0;\r\n        // first determine which children (slides) should be used in our height calculation\r\n        var children = $();\r\n        // if mode is not \"vertical\" and adaptiveHeight is false, include all children\r\n        if (slider.settings.mode !== 'vertical' && !slider.settings.adaptiveHeight) {\r\n          children = slider.children;\r\n        } else {\r\n          // if not carousel, return the single active child\r\n          if (!slider.carousel) {\r\n            children = slider.children.eq(slider.active.index);\r\n          // if carousel, return a slice of children\r\n          } else {\r\n            // get the individual slide index\r\n            var currentIndex = slider.settings.moveSlides === 1 ? slider.active.index : slider.active.index * getMoveBy();\r\n            // add the current slide to the children\r\n            children = slider.children.eq(currentIndex);\r\n            // cycle through the remaining \"showing\" slides\r\n            for (i = 1; i <= slider.settings.maxSlides - 1; i++) {\r\n              // if looped back to the start\r\n              if (currentIndex + i >= slider.children.length) {\r\n                children = children.add(slider.children.eq(i - 1));\r\n              } else {\r\n                children = children.add(slider.children.eq(currentIndex + i));\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // if \"vertical\" mode, calculate the sum of the heights of the children\r\n        if (slider.settings.mode === 'vertical') {\r\n          children.each(function(index) {\r\n            height += $(this).outerHeight();\r\n          });\r\n          // add user-supplied margins\r\n          if (slider.settings.slideMargin > 0) {\r\n            height += slider.settings.slideMargin * (slider.settings.minSlides - 1);\r\n          }\r\n        // if not \"vertical\" mode, calculate the max height of the children\r\n        } else {\r\n          height = Math.max.apply(Math, children.map(function() {\r\n            return $(this).outerHeight(false);\r\n          }).get());\r\n        }\r\n  \r\n        if (slider.viewport.css('box-sizing') === 'border-box') {\r\n          height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) +\r\n                parseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));\r\n        } else if (slider.viewport.css('box-sizing') === 'padding-box') {\r\n          height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));\r\n        }\r\n  \r\n        return height;\r\n      };\r\n  \r\n      /**\r\n       * Returns the calculated width to be used for the outer wrapper / viewport\r\n       */\r\n      var getViewportMaxWidth = function() {\r\n        var width = '100%';\r\n        if (slider.settings.slideWidth > 0) {\r\n          if (slider.settings.mode === 'horizontal') {\r\n            width = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);\r\n          } else {\r\n            width = slider.settings.slideWidth;\r\n          }\r\n        }\r\n        return width;\r\n      };\r\n  \r\n      /**\r\n       * Returns the calculated width to be applied to each slide\r\n       */\r\n      var getSlideWidth = function() {\r\n        var newElWidth = slider.settings.slideWidth, // start with any user-supplied slide width\r\n        wrapWidth      = slider.viewport.width();    // get the current viewport width\r\n        // if slide width was not supplied, or is larger than the viewport use the viewport width\r\n        if (slider.settings.slideWidth === 0 ||\r\n          (slider.settings.slideWidth > wrapWidth && !slider.carousel) ||\r\n          slider.settings.mode === 'vertical') {\r\n          newElWidth = wrapWidth;\r\n        // if carousel, use the thresholds to determine the width\r\n        } else if (slider.settings.maxSlides > 1 && slider.settings.mode === 'horizontal') {\r\n          if (wrapWidth > slider.maxThreshold) {\r\n            return newElWidth;\r\n          } else if (wrapWidth < slider.minThreshold) {\r\n            newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;\r\n          } else if (slider.settings.shrinkItems) {\r\n            newElWidth = Math.floor((wrapWidth + slider.settings.slideMargin) / (Math.ceil((wrapWidth + slider.settings.slideMargin) / (newElWidth + slider.settings.slideMargin))) - slider.settings.slideMargin);\r\n          }\r\n        }\r\n        return newElWidth;\r\n      };\r\n  \r\n      /**\r\n       * Returns the number of slides currently visible in the viewport (includes partially visible slides)\r\n       */\r\n      var getNumberSlidesShowing = function() {\r\n        var slidesShowing = 1,\r\n        childWidth = null;\r\n        if (slider.settings.mode === 'horizontal' && slider.settings.slideWidth > 0) {\r\n          // if viewport is smaller than minThreshold, return minSlides\r\n          if (slider.viewport.width() < slider.minThreshold) {\r\n            slidesShowing = slider.settings.minSlides;\r\n          // if viewport is larger than maxThreshold, return maxSlides\r\n          } else if (slider.viewport.width() > slider.maxThreshold) {\r\n            slidesShowing = slider.settings.maxSlides;\r\n          // if viewport is between min / max thresholds, divide viewport width by first child width\r\n          } else {\r\n            childWidth = slider.children.first().width() + slider.settings.slideMargin;\r\n            slidesShowing = Math.floor((slider.viewport.width() +\r\n              slider.settings.slideMargin) / childWidth) || 1;\r\n          }\r\n        // if \"vertical\" mode, slides showing will always be minSlides\r\n        } else if (slider.settings.mode === 'vertical') {\r\n          slidesShowing = slider.settings.minSlides;\r\n        }\r\n        return slidesShowing;\r\n      };\r\n  \r\n      /**\r\n       * Returns the number of pages (one full viewport of slides is one \"page\")\r\n       */\r\n      var getPagerQty = function() {\r\n        var pagerQty = 0,\r\n        breakPoint = 0,\r\n        counter = 0;\r\n        // if moveSlides is specified by the user\r\n        if (slider.settings.moveSlides > 0) {\r\n          if (slider.settings.infiniteLoop) {\r\n            pagerQty = Math.ceil(slider.children.length / getMoveBy());\r\n          } else {\r\n            // when breakpoint goes above children length, counter is the number of pages\r\n            while (breakPoint < slider.children.length) {\r\n              ++pagerQty;\r\n              breakPoint = counter + getNumberSlidesShowing();\r\n              counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();\r\n            }\r\n        return counter;\r\n          }\r\n        // if moveSlides is 0 (auto) divide children length by sides showing, then round up\r\n        } else {\r\n          pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());\r\n        }\r\n        return pagerQty;\r\n      };\r\n  \r\n      /**\r\n       * Returns the number of individual slides by which to shift the slider\r\n       */\r\n      var getMoveBy = function() {\r\n        // if moveSlides was set by the user and moveSlides is less than number of slides showing\r\n        if (slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()) {\r\n          return slider.settings.moveSlides;\r\n        }\r\n        // if moveSlides is 0 (auto)\r\n        return getNumberSlidesShowing();\r\n      };\r\n  \r\n      /**\r\n       * Sets the slider's (el) left or top position\r\n       */\r\n      var setSlidePosition = function() {\r\n        var position, lastChild, lastShowingIndex;\r\n        // if last slide, not infinite loop, and number of children is larger than specified maxSlides\r\n        if (slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop) {\r\n          if (slider.settings.mode === 'horizontal') {\r\n            // get the last child's position\r\n            lastChild = slider.children.last();\r\n            position = lastChild.position();\r\n            // set the left position\r\n            setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);\r\n          } else if (slider.settings.mode === 'vertical') {\r\n            // get the last showing index's position\r\n            lastShowingIndex = slider.children.length - slider.settings.minSlides;\r\n            position = slider.children.eq(lastShowingIndex).position();\r\n            // set the top position\r\n            setPositionProperty(-position.top, 'reset', 0);\r\n          }\r\n        // if not last slide\r\n        } else {\r\n          // get the position of the first showing slide\r\n          position = slider.children.eq(slider.active.index * getMoveBy()).position();\r\n          // check for last slide\r\n          if (slider.active.index === getPagerQty() - 1) { slider.active.last = true; }\r\n          // set the respective position\r\n          if (position !== undefined) {\r\n            if (slider.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }\r\n            else if (slider.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }\r\n          }\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Sets the el's animating property position (which in turn will sometimes animate el).\r\n       * If using CSS, sets the transform property. If not using CSS, sets the top / left property.\r\n       *\r\n       * @param value (int)\r\n       *  - the animating property's value\r\n       *\r\n       * @param type (string) 'slide', 'reset', 'ticker'\r\n       *  - the type of instance for which the function is being\r\n       *\r\n       * @param duration (int)\r\n       *  - the amount of time (in ms) the transition should occupy\r\n       *\r\n       * @param params (array) optional\r\n       *  - an optional parameter containing any variables that need to be passed in\r\n       */\r\n      var setPositionProperty = function(value, type, duration, params) {\r\n        var animateObj, propValue;\r\n        // use CSS transform\r\n        if (slider.usingCSS) {\r\n          // determine the translate3d value\r\n          propValue = slider.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';\r\n          // add the CSS transition-duration\r\n          el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');\r\n          if (type === 'slide') {\r\n            // set the property value\r\n            el.css(slider.animProp, propValue);\r\n            if (duration !== 0) {\r\n              // bind a callback method - executes when CSS transition completes\r\n              el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {\r\n                //make sure it's the correct one\r\n                if (!$(e.target).is(el)) { return; }\r\n                // unbind the callback\r\n                el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\r\n                updateAfterSlideTransition();\r\n              });\r\n            } else { //duration = 0\r\n              updateAfterSlideTransition();\r\n            }\r\n          } else if (type === 'reset') {\r\n            el.css(slider.animProp, propValue);\r\n          } else if (type === 'ticker') {\r\n            // make the transition use 'linear'\r\n            el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');\r\n            el.css(slider.animProp, propValue);\r\n            if (duration !== 0) {\r\n              el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {\r\n                //make sure it's the correct one\r\n                if (!$(e.target).is(el)) { return; }\r\n                // unbind the callback\r\n                el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\r\n                // reset the position\r\n                setPositionProperty(params.resetValue, 'reset', 0);\r\n                // start the loop again\r\n                tickerLoop();\r\n              });\r\n            } else { //duration = 0\r\n              setPositionProperty(params.resetValue, 'reset', 0);\r\n              tickerLoop();\r\n            }\r\n          }\r\n        // use JS animate\r\n        } else {\r\n          animateObj = {};\r\n          animateObj[slider.animProp] = value;\r\n          if (type === 'slide') {\r\n            el.animate(animateObj, duration, slider.settings.easing, function() {\r\n              updateAfterSlideTransition();\r\n            });\r\n          } else if (type === 'reset') {\r\n            el.css(slider.animProp, value);\r\n          } else if (type === 'ticker') {\r\n            el.animate(animateObj, duration, 'linear', function() {\r\n              setPositionProperty(params.resetValue, 'reset', 0);\r\n              // run the recursive loop after animation\r\n              tickerLoop();\r\n            });\r\n          }\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Populates the pager with proper amount of pages\r\n       */\r\n      var populatePager = function() {\r\n        var pagerHtml = '',\r\n        linkContent = '',\r\n        pagerQty = getPagerQty();\r\n        // loop through each pager item\r\n        for (var i = 0; i < pagerQty; i++) {\r\n          linkContent = '';\r\n          // if a buildPager function is supplied, use it to get pager link value, else use index + 1\r\n          if (slider.settings.buildPager && $.isFunction(slider.settings.buildPager) || slider.settings.pagerCustom) {\r\n            linkContent = slider.settings.buildPager(i);\r\n            slider.pagerEl.addClass('bx-custom-pager');\r\n          } else {\r\n            linkContent = i + 1;\r\n            slider.pagerEl.addClass('bx-default-pager');\r\n          }\r\n          // var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;\r\n          // add the markup to the string\r\n          pagerHtml += '<div class=\"bx-pager-item\"><a href=\"\" data-slide-index=\"' + i + '\" class=\"bx-pager-link\">' + linkContent + '</a></div>';\r\n        }\r\n        // populate the pager element with pager links\r\n        slider.pagerEl.html(pagerHtml);\r\n      };\r\n  \r\n      /**\r\n       * Appends the pager to the controls element\r\n       */\r\n      var appendPager = function() {\r\n        if (!slider.settings.pagerCustom) {\r\n          // create the pager DOM element\r\n          slider.pagerEl = $('<div class=\"bx-pager\" />');\r\n          // if a pager selector was supplied, populate it with the pager\r\n          if (slider.settings.pagerSelector) {\r\n            $(slider.settings.pagerSelector).html(slider.pagerEl);\r\n          // if no pager selector was supplied, add it after the wrapper\r\n          } else {\r\n            slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);\r\n          }\r\n          // populate the pager\r\n          populatePager();\r\n        } else {\r\n          slider.pagerEl = $(slider.settings.pagerCustom);\r\n        }\r\n        // assign the pager click binding\r\n        slider.pagerEl.on('click touchend', 'a', clickPagerBind);\r\n      };\r\n  \r\n      /**\r\n       * Appends prev / next controls to the controls element\r\n       */\r\n      var appendControls = function() {\r\n        slider.controls.next = $('<a class=\"bx-next\" href=\"\">' + slider.settings.nextText + '</a>');\r\n        slider.controls.prev = $('<a class=\"bx-prev\" href=\"\">' + slider.settings.prevText + '</a>');\r\n        // bind click actions to the controls\r\n        slider.controls.next.bind('click touchend', clickNextBind);\r\n        slider.controls.prev.bind('click touchend', clickPrevBind);\r\n        // if nextSelector was supplied, populate it\r\n        if (slider.settings.nextSelector) {\r\n          $(slider.settings.nextSelector).append(slider.controls.next);\r\n        }\r\n        // if prevSelector was supplied, populate it\r\n        if (slider.settings.prevSelector) {\r\n          $(slider.settings.prevSelector).append(slider.controls.prev);\r\n        }\r\n        // if no custom selectors were supplied\r\n        if (!slider.settings.nextSelector && !slider.settings.prevSelector) {\r\n          // add the controls to the DOM\r\n          slider.controls.directionEl = $('<div class=\"bx-controls-direction\" />');\r\n          // add the control elements to the directionEl\r\n          slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);\r\n          // slider.viewport.append(slider.controls.directionEl);\r\n          slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Appends start / stop auto controls to the controls element\r\n       */\r\n      var appendControlsAuto = function() {\r\n        slider.controls.start = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-start\" href=\"\">' + slider.settings.startText + '</a></div>');\r\n        slider.controls.stop = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-stop\" href=\"\">' + slider.settings.stopText + '</a></div>');\r\n        // add the controls to the DOM\r\n        slider.controls.autoEl = $('<div class=\"bx-controls-auto\" />');\r\n        // bind click actions to the controls\r\n        slider.controls.autoEl.on('click', '.bx-start', clickStartBind);\r\n        slider.controls.autoEl.on('click', '.bx-stop', clickStopBind);\r\n        // if autoControlsCombine, insert only the \"start\" control\r\n        if (slider.settings.autoControlsCombine) {\r\n          slider.controls.autoEl.append(slider.controls.start);\r\n        // if autoControlsCombine is false, insert both controls\r\n        } else {\r\n          slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);\r\n        }\r\n        // if auto controls selector was supplied, populate it with the controls\r\n        if (slider.settings.autoControlsSelector) {\r\n          $(slider.settings.autoControlsSelector).html(slider.controls.autoEl);\r\n        // if auto controls selector was not supplied, add it after the wrapper\r\n        } else {\r\n          slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);\r\n        }\r\n        // update the auto controls\r\n        updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');\r\n      };\r\n  \r\n      /**\r\n       * Appends image captions to the DOM\r\n       */\r\n      var appendCaptions = function() {\r\n        // cycle through each child\r\n        slider.children.each(function(index) {\r\n          // get the image title attribute\r\n          var title = $(this).find('img:first').attr('title');\r\n          // append the caption\r\n          if (title !== undefined && ('' + title).length) {\r\n            $(this).append('<div class=\"bx-caption\"><span>' + title + '</span></div>');\r\n          }\r\n        });\r\n      };\r\n  \r\n      /**\r\n       * Click next binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var clickNextBind = function(e) {\r\n        e.preventDefault();\r\n        if (slider.controls.el.hasClass('disabled')) { return; }\r\n        // if auto show is running, stop it\r\n        if (slider.settings.auto && slider.settings.stopAutoOnClick) { el.stopAuto(); }\r\n        el.goToNextSlide();\r\n      };\r\n  \r\n      /**\r\n       * Click prev binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var clickPrevBind = function(e) {\r\n        e.preventDefault();\r\n        if (slider.controls.el.hasClass('disabled')) { return; }\r\n        // if auto show is running, stop it\r\n        if (slider.settings.auto && slider.settings.stopAutoOnClick) { el.stopAuto(); }\r\n        el.goToPrevSlide();\r\n      };\r\n  \r\n      /**\r\n       * Click start binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var clickStartBind = function(e) {\r\n        el.startAuto();\r\n        e.preventDefault();\r\n      };\r\n  \r\n      /**\r\n       * Click stop binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var clickStopBind = function(e) {\r\n        el.stopAuto();\r\n        e.preventDefault();\r\n      };\r\n  \r\n      /**\r\n       * Click pager binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var clickPagerBind = function(e) {\r\n        var pagerLink, pagerIndex;\r\n        e.preventDefault();\r\n        if (slider.controls.el.hasClass('disabled')) {\r\n          return;\r\n        }\r\n        // if auto show is running, stop it\r\n        if (slider.settings.auto  && slider.settings.stopAutoOnClick) { el.stopAuto(); }\r\n        pagerLink = $(e.currentTarget);\r\n        if (pagerLink.attr('data-slide-index') !== undefined) {\r\n          pagerIndex = parseInt(pagerLink.attr('data-slide-index'));\r\n          // if clicked pager link is not active, continue with the goToSlide call\r\n          if (pagerIndex !== slider.active.index) { el.goToSlide(pagerIndex); }\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Updates the pager links with an active class\r\n       *\r\n       * @param slideIndex (int)\r\n       *  - index of slide to make active\r\n       */\r\n      var updatePagerActive = function(slideIndex) {\r\n        // if \"short\" pager type\r\n        var len = slider.children.length; // nb of children\r\n        if (slider.settings.pagerType === 'short') {\r\n          if (slider.settings.maxSlides > 1) {\r\n            len = Math.ceil(slider.children.length / slider.settings.maxSlides);\r\n          }\r\n          slider.pagerEl.html((slideIndex + 1) + slider.settings.pagerShortSeparator + len);\r\n          return;\r\n        }\r\n        // remove all pager active classes\r\n        slider.pagerEl.find('a').removeClass('active');\r\n        // apply the active class for all pagers\r\n        slider.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });\r\n      };\r\n  \r\n      /**\r\n       * Performs needed actions after a slide transition\r\n       */\r\n      var updateAfterSlideTransition = function() {\r\n        // if infinite loop is true\r\n        if (slider.settings.infiniteLoop) {\r\n          var position = '';\r\n          // first slide\r\n          if (slider.active.index === 0) {\r\n            // set the new position\r\n            position = slider.children.eq(0).position();\r\n          // carousel, last slide\r\n          } else if (slider.active.index === getPagerQty() - 1 && slider.carousel) {\r\n            position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();\r\n          // last slide\r\n          } else if (slider.active.index === slider.children.length - 1) {\r\n            position = slider.children.eq(slider.children.length - 1).position();\r\n          }\r\n          if (position) {\r\n            if (slider.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }\r\n            else if (slider.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }\r\n          }\r\n        }\r\n        // declare that the transition is complete\r\n        slider.working = false;\r\n        // onSlideAfter callback\r\n        slider.settings.onSlideAfter.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\r\n      };\r\n  \r\n      /**\r\n       * Updates the auto controls state (either active, or combined switch)\r\n       *\r\n       * @param state (string) \"start\", \"stop\"\r\n       *  - the new state of the auto show\r\n       */\r\n      var updateAutoControls = function(state) {\r\n        // if autoControlsCombine is true, replace the current control with the new state\r\n        if (slider.settings.autoControlsCombine) {\r\n          slider.controls.autoEl.html(slider.controls[state]);\r\n        // if autoControlsCombine is false, apply the \"active\" class to the appropriate control\r\n        } else {\r\n          slider.controls.autoEl.find('a').removeClass('active');\r\n          slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Updates the direction controls (checks if either should be hidden)\r\n       */\r\n      var updateDirectionControls = function() {\r\n        if (getPagerQty() === 1) {\r\n          slider.controls.prev.addClass('disabled');\r\n          slider.controls.next.addClass('disabled');\r\n        } else if (!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd) {\r\n          // if first slide\r\n          if (slider.active.index === 0) {\r\n            slider.controls.prev.addClass('disabled');\r\n            slider.controls.next.removeClass('disabled');\r\n          // if last slide\r\n          } else if (slider.active.index === getPagerQty() - 1) {\r\n            slider.controls.next.addClass('disabled');\r\n            slider.controls.prev.removeClass('disabled');\r\n          // if any slide in the middle\r\n          } else {\r\n            slider.controls.prev.removeClass('disabled');\r\n            slider.controls.next.removeClass('disabled');\r\n          }\r\n        }\r\n      };\r\n    /* auto start and stop functions */\r\n    var windowFocusHandler = function() { el.startAuto(); };\r\n    var windowBlurHandler = function() { el.stopAuto(); };\r\n      /**\r\n       * Initializes the auto process\r\n       */\r\n      var initAuto = function() {\r\n        // if autoDelay was supplied, launch the auto show using a setTimeout() call\r\n        if (slider.settings.autoDelay > 0) {\r\n          var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);\r\n        // if autoDelay was not supplied, start the auto show normally\r\n        } else {\r\n          el.startAuto();\r\n  \r\n          //add focus and blur events to ensure its running if timeout gets paused\r\n          $(window).focus(windowFocusHandler).blur(windowBlurHandler);\r\n        }\r\n        // if autoHover is requested\r\n        if (slider.settings.autoHover) {\r\n          // on el hover\r\n          el.hover(function() {\r\n            // if the auto show is currently playing (has an active interval)\r\n            if (slider.interval) {\r\n              // stop the auto show and pass true argument which will prevent control update\r\n              el.stopAuto(true);\r\n              // create a new autoPaused value which will be used by the relative \"mouseout\" event\r\n              slider.autoPaused = true;\r\n            }\r\n          }, function() {\r\n            // if the autoPaused value was created be the prior \"mouseover\" event\r\n            if (slider.autoPaused) {\r\n              // start the auto show and pass true argument which will prevent control update\r\n              el.startAuto(true);\r\n              // reset the autoPaused value\r\n              slider.autoPaused = null;\r\n            }\r\n          });\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Initializes the ticker process\r\n       */\r\n      var initTicker = function() {\r\n        var startPosition = 0,\r\n        position, transform, value, idx, ratio, property, newSpeed, totalDimens;\r\n        // if autoDirection is \"next\", append a clone of the entire slider\r\n        if (slider.settings.autoDirection === 'next') {\r\n          el.append(slider.children.clone().addClass('bx-clone'));\r\n        // if autoDirection is \"prev\", prepend a clone of the entire slider, and set the left position\r\n        } else {\r\n          el.prepend(slider.children.clone().addClass('bx-clone'));\r\n          position = slider.children.first().position();\r\n          startPosition = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\r\n        }\r\n        setPositionProperty(startPosition, 'reset', 0);\r\n        // do not allow controls in ticker mode\r\n        slider.settings.pager = false;\r\n        slider.settings.controls = false;\r\n        slider.settings.autoControls = false;\r\n        // if autoHover is requested\r\n        if (slider.settings.tickerHover) {\r\n          if (slider.usingCSS) {\r\n            idx = slider.settings.mode === 'horizontal' ? 4 : 5;\r\n            slider.viewport.hover(function() {\r\n              transform = el.css('-' + slider.cssPrefix + '-transform');\r\n              value = parseFloat(transform.split(',')[idx]);\r\n              setPositionProperty(value, 'reset', 0);\r\n            }, function() {\r\n              totalDimens = 0;\r\n              slider.children.each(function(index) {\r\n                totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\r\n              });\r\n              // calculate the speed ratio (used to determine the new speed to finish the paused animation)\r\n              ratio = slider.settings.speed / totalDimens;\r\n              // determine which property to use\r\n              property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\r\n              // calculate the new speed\r\n              newSpeed = ratio * (totalDimens - (Math.abs(parseInt(value))));\r\n              tickerLoop(newSpeed);\r\n            });\r\n          } else {\r\n            // on el hover\r\n            slider.viewport.hover(function() {\r\n              el.stop();\r\n            }, function() {\r\n              // calculate the total width of children (used to calculate the speed ratio)\r\n              totalDimens = 0;\r\n              slider.children.each(function(index) {\r\n                totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\r\n              });\r\n              // calculate the speed ratio (used to determine the new speed to finish the paused animation)\r\n              ratio = slider.settings.speed / totalDimens;\r\n              // determine which property to use\r\n              property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\r\n              // calculate the new speed\r\n              newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));\r\n              tickerLoop(newSpeed);\r\n            });\r\n          }\r\n        }\r\n        // start the ticker loop\r\n        tickerLoop();\r\n      };\r\n  \r\n      /**\r\n       * Runs a continuous loop, news ticker-style\r\n       */\r\n      var tickerLoop = function(resumeSpeed) {\r\n        var speed = resumeSpeed ? resumeSpeed : slider.settings.speed,\r\n        position = {left: 0, top: 0},\r\n        reset = {left: 0, top: 0},\r\n        animateProperty, resetValue, params;\r\n  \r\n        // if \"next\" animate left position to last child, then reset left to 0\r\n        if (slider.settings.autoDirection === 'next') {\r\n          position = el.find('.bx-clone').first().position();\r\n        // if \"prev\" animate left position to 0, then reset left to first non-clone child\r\n        } else {\r\n          reset = slider.children.first().position();\r\n        }\r\n        animateProperty = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\r\n        resetValue = slider.settings.mode === 'horizontal' ? -reset.left : -reset.top;\r\n        params = {resetValue: resetValue};\r\n        setPositionProperty(animateProperty, 'ticker', speed, params);\r\n      };\r\n  \r\n      /**\r\n       * Check if el is on screen\r\n       */\r\n      var isOnScreen = function(el) {\r\n        var win = $(window),\r\n        viewport = {\r\n          top: win.scrollTop(),\r\n          left: win.scrollLeft()\r\n        },\r\n        bounds = el.offset();\r\n  \r\n        viewport.right = viewport.left + win.width();\r\n        viewport.bottom = viewport.top + win.height();\r\n        bounds.right = bounds.left + el.outerWidth();\r\n        bounds.bottom = bounds.top + el.outerHeight();\r\n  \r\n        return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));\r\n      };\r\n  \r\n      /**\r\n       * Initializes keyboard events\r\n       */\r\n      var keyPress = function(e) {\r\n        var activeElementTag = document.activeElement.tagName.toLowerCase(),\r\n        tagFilters = 'input|textarea',\r\n        p = new RegExp(activeElementTag,['i']),\r\n        result = p.exec(tagFilters);\r\n  \r\n        if (result == null && isOnScreen(el)) {\r\n          if (e.keyCode === 39) {\r\n            clickNextBind(e);\r\n            return false;\r\n          } else if (e.keyCode === 37) {\r\n            clickPrevBind(e);\r\n            return false;\r\n          }\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Initializes touch events\r\n       */\r\n      var initTouch = function() {\r\n        // initialize object to contain all touch values\r\n        slider.touch = {\r\n          start: {x: 0, y: 0},\r\n          end: {x: 0, y: 0}\r\n        };\r\n        slider.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);\r\n  \r\n        //for browsers that have implemented pointer events and fire a click after\r\n        //every pointerup regardless of whether pointerup is on same screen location as pointerdown or not\r\n        slider.viewport.on('click', '.bxslider a', function(e) {\r\n          if (slider.viewport.hasClass('click-disabled')) {\r\n            e.preventDefault();\r\n            slider.viewport.removeClass('click-disabled');\r\n          }\r\n        });\r\n      };\r\n  \r\n      /**\r\n       * Event handler for \"touchstart\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var onTouchStart = function(e) {\r\n        //disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls\r\n        slider.controls.el.addClass('disabled');\r\n  \r\n        if (slider.working) {\r\n          e.preventDefault();\r\n          slider.controls.el.removeClass('disabled');\r\n        } else {\r\n          // record the original position when touch starts\r\n          slider.touch.originalPos = el.position();\r\n          var orig = e.originalEvent,\r\n          touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig];\r\n          // record the starting touch x, y coordinates\r\n          slider.touch.start.x = touchPoints[0].pageX;\r\n          slider.touch.start.y = touchPoints[0].pageY;\r\n  \r\n          if (slider.viewport.get(0).setPointerCapture) {\r\n            slider.pointerId = orig.pointerId;\r\n            slider.viewport.get(0).setPointerCapture(slider.pointerId);\r\n          }\r\n          // bind a \"touchmove\" event to the viewport\r\n          slider.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);\r\n          // bind a \"touchend\" event to the viewport\r\n          slider.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);\r\n          slider.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Cancel Pointer for Windows Phone\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var onPointerCancel = function(e) {\r\n        /* onPointerCancel handler is needed to deal with situations when a touchend\r\n        doesn't fire after a touchstart (this happens on windows phones only) */\r\n        setPositionProperty(slider.touch.originalPos.left, 'reset', 0);\r\n  \r\n        //remove handlers\r\n        slider.controls.el.removeClass('disabled');\r\n        slider.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);\r\n        slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\r\n        slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\r\n        if (slider.viewport.get(0).releasePointerCapture) {\r\n          slider.viewport.get(0).releasePointerCapture(slider.pointerId);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Event handler for \"touchmove\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var onTouchMove = function(e) {\r\n        var orig = e.originalEvent,\r\n        touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],\r\n        // if scrolling on y axis, do not prevent default\r\n        xMovement = Math.abs(touchPoints[0].pageX - slider.touch.start.x),\r\n        yMovement = Math.abs(touchPoints[0].pageY - slider.touch.start.y),\r\n        value = 0,\r\n        change = 0;\r\n  \r\n        // x axis swipe\r\n        if ((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX) {\r\n          e.preventDefault();\r\n        // y axis swipe\r\n        } else if ((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY) {\r\n          e.preventDefault();\r\n        }\r\n        if (slider.settings.mode !== 'fade' && slider.settings.oneToOneTouch) {\r\n          // if horizontal, drag along x axis\r\n          if (slider.settings.mode === 'horizontal') {\r\n            change = touchPoints[0].pageX - slider.touch.start.x;\r\n            value = slider.touch.originalPos.left + change;\r\n          // if vertical, drag along y axis\r\n          } else {\r\n            change = touchPoints[0].pageY - slider.touch.start.y;\r\n            value = slider.touch.originalPos.top + change;\r\n          }\r\n          setPositionProperty(value, 'reset', 0);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Event handler for \"touchend\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\r\n      var onTouchEnd = function(e) {\r\n        slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\r\n        //enable slider controls as soon as user stops interacing with slides\r\n        slider.controls.el.removeClass('disabled');\r\n        var orig    = e.originalEvent,\r\n        touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],\r\n        value       = 0,\r\n        distance    = 0;\r\n        // record end x, y positions\r\n        slider.touch.end.x = touchPoints[0].pageX;\r\n        slider.touch.end.y = touchPoints[0].pageY;\r\n        // if fade mode, check if absolute x distance clears the threshold\r\n        if (slider.settings.mode === 'fade') {\r\n          distance = Math.abs(slider.touch.start.x - slider.touch.end.x);\r\n          if (distance >= slider.settings.swipeThreshold) {\r\n            if (slider.touch.start.x > slider.touch.end.x) {\r\n              el.goToNextSlide();\r\n            } else {\r\n              el.goToPrevSlide();\r\n            }\r\n            el.stopAuto();\r\n          }\r\n        // not fade mode\r\n        } else {\r\n          // calculate distance and el's animate property\r\n          if (slider.settings.mode === 'horizontal') {\r\n            distance = slider.touch.end.x - slider.touch.start.x;\r\n            value = slider.touch.originalPos.left;\r\n          } else {\r\n            distance = slider.touch.end.y - slider.touch.start.y;\r\n            value = slider.touch.originalPos.top;\r\n          }\r\n          // if not infinite loop and first / last slide, do not attempt a slide transition\r\n          if (!slider.settings.infiniteLoop && ((slider.active.index === 0 && distance > 0) || (slider.active.last && distance < 0))) {\r\n            setPositionProperty(value, 'reset', 200);\r\n          } else {\r\n            // check if distance clears threshold\r\n            if (Math.abs(distance) >= slider.settings.swipeThreshold) {\r\n              if (distance < 0) {\r\n                el.goToNextSlide();\r\n              } else {\r\n                el.goToPrevSlide();\r\n              }\r\n              el.stopAuto();\r\n            } else {\r\n              // el.animate(property, 200);\r\n              setPositionProperty(value, 'reset', 200);\r\n            }\r\n          }\r\n        }\r\n        slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\r\n        if (slider.viewport.get(0).releasePointerCapture) {\r\n          slider.viewport.get(0).releasePointerCapture(slider.pointerId);\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Window resize event callback\r\n       */\r\n      var resizeWindow = function(e) {\r\n        // don't do anything if slider isn't initialized.\r\n        if (!slider.initialized) { return; }\r\n        // Delay if slider working.\r\n        if (slider.working) {\r\n          window.setTimeout(resizeWindow, 10);\r\n        } else {\r\n          // get the new window dimens (again, thank you IE)\r\n          var windowWidthNew = $(window).width(),\r\n          windowHeightNew = $(window).height();\r\n          // make sure that it is a true window resize\r\n          // *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements\r\n          // are resized. Can you just die already?*\r\n          if (windowWidth !== windowWidthNew || windowHeight !== windowHeightNew) {\r\n            // set the new window dimens\r\n            windowWidth = windowWidthNew;\r\n            windowHeight = windowHeightNew;\r\n            // update all dynamic elements\r\n            el.redrawSlider();\r\n            // Call user resize handler\r\n            slider.settings.onSliderResize.call(el, slider.active.index);\r\n          }\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Adds an aria-hidden=true attribute to each element\r\n       *\r\n       * @param startVisibleIndex (int)\r\n       *  - the first visible element's index\r\n       */\r\n      var applyAriaHiddenAttributes = function(startVisibleIndex) {\r\n        var numberOfSlidesShowing = getNumberSlidesShowing();\r\n        // only apply attributes if the setting is enabled and not in ticker mode\r\n        if (slider.settings.ariaHidden && !slider.settings.ticker) {\r\n          // add aria-hidden=true to all elements\r\n          slider.children.attr('aria-hidden', 'true');\r\n          // get the visible elements and change to aria-hidden=false\r\n          slider.children.slice(startVisibleIndex, startVisibleIndex + numberOfSlidesShowing).attr('aria-hidden', 'false');\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * Returns index according to present page range\r\n       *\r\n       * @param slideOndex (int)\r\n       *  - the desired slide index\r\n       */\r\n      var setSlideIndex = function(slideIndex) {\r\n        if (slideIndex < 0) {\r\n          if (slider.settings.infiniteLoop) {\r\n            return getPagerQty() - 1;\r\n          }else {\r\n            //we don't go to undefined slides\r\n            return slider.active.index;\r\n          }\r\n        // if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)\r\n        } else if (slideIndex >= getPagerQty()) {\r\n          if (slider.settings.infiniteLoop) {\r\n            return 0;\r\n          } else {\r\n            //we don't move to undefined pages\r\n            return slider.active.index;\r\n          }\r\n        // set active index to requested slide\r\n        } else {\r\n          return slideIndex;\r\n        }\r\n      };\r\n  \r\n      /**\r\n       * ===================================================================================\r\n       * = PUBLIC FUNCTIONS\r\n       * ===================================================================================\r\n       */\r\n  \r\n      /**\r\n       * Performs slide transition to the specified slide\r\n       *\r\n       * @param slideIndex (int)\r\n       *  - the destination slide's index (zero-based)\r\n       *\r\n       * @param direction (string)\r\n       *  - INTERNAL USE ONLY - the direction of travel (\"prev\" / \"next\")\r\n       */\r\n      el.goToSlide = function(slideIndex, direction) {\r\n        // onSlideBefore, onSlideNext, onSlidePrev callbacks\r\n        // Allow transition canceling based on returned value\r\n        var performTransition = true,\r\n        moveBy = 0,\r\n        position = {left: 0, top: 0},\r\n        lastChild = null,\r\n        lastShowingIndex, eq, value, requestEl;\r\n        // store the old index\r\n        slider.oldIndex = slider.active.index;\r\n        //set new index\r\n        slider.active.index = setSlideIndex(slideIndex);\r\n  \r\n        // if plugin is currently in motion, ignore request\r\n        if (slider.working || slider.active.index === slider.oldIndex) { return; }\r\n        // declare that plugin is in motion\r\n        slider.working = true;\r\n  \r\n        performTransition = slider.settings.onSlideBefore.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\r\n  \r\n        // If transitions canceled, reset and return\r\n        if (typeof (performTransition) !== 'undefined' && !performTransition) {\r\n          slider.active.index = slider.oldIndex; // restore old index\r\n          slider.working = false; // is not in motion\r\n          return;\r\n        }\r\n  \r\n        if (direction === 'next') {\r\n          // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\r\n          if (!slider.settings.onSlideNext.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\r\n            performTransition = false;\r\n          }\r\n        } else if (direction === 'prev') {\r\n          // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\r\n          if (!slider.settings.onSlidePrev.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\r\n            performTransition = false;\r\n          }\r\n        }\r\n  \r\n        // check if last slide\r\n        slider.active.last = slider.active.index >= getPagerQty() - 1;\r\n        // update the pager with active class\r\n        if (slider.settings.pager || slider.settings.pagerCustom) { updatePagerActive(slider.active.index); }\r\n        // // check for direction control update\r\n        if (slider.settings.controls) { updateDirectionControls(); }\r\n        // if slider is set to mode: \"fade\"\r\n        if (slider.settings.mode === 'fade') {\r\n          // if adaptiveHeight is true and next height is different from current height, animate to the new height\r\n          if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\r\n            slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);\r\n          }\r\n          // fade out the visible child and reset its z-index value\r\n          slider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});\r\n          // fade in the newly requested slide\r\n          slider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex + 1).fadeIn(slider.settings.speed, function() {\r\n            $(this).css('zIndex', slider.settings.slideZIndex);\r\n            updateAfterSlideTransition();\r\n          });\r\n        // slider mode is not \"fade\"\r\n        } else {\r\n          // if adaptiveHeight is true and next height is different from current height, animate to the new height\r\n          if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\r\n            slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);\r\n          }\r\n          // if carousel and not infinite loop\r\n          if (!slider.settings.infiniteLoop && slider.carousel && slider.active.last) {\r\n            if (slider.settings.mode === 'horizontal') {\r\n              // get the last child position\r\n              lastChild = slider.children.eq(slider.children.length - 1);\r\n              position = lastChild.position();\r\n              // calculate the position of the last slide\r\n              moveBy = slider.viewport.width() - lastChild.outerWidth();\r\n            } else {\r\n              // get last showing index position\r\n              lastShowingIndex = slider.children.length - slider.settings.minSlides;\r\n              position = slider.children.eq(lastShowingIndex).position();\r\n            }\r\n            // horizontal carousel, going previous while on first slide (infiniteLoop mode)\r\n          } else if (slider.carousel && slider.active.last && direction === 'prev') {\r\n            // get the last child position\r\n            eq = slider.settings.moveSlides === 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);\r\n            lastChild = el.children('.bx-clone').eq(eq);\r\n            position = lastChild.position();\r\n          // if infinite loop and \"Next\" is clicked on the last slide\r\n          } else if (direction === 'next' && slider.active.index === 0) {\r\n            // get the last clone position\r\n            position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();\r\n            slider.active.last = false;\r\n          // normal non-zero requests\r\n          } else if (slideIndex >= 0) {\r\n            //parseInt is applied to allow floats for slides/page\r\n            requestEl = slideIndex * parseInt(getMoveBy());\r\n            position = slider.children.eq(requestEl).position();\r\n          }\r\n  \r\n          /* If the position doesn't exist\r\n           * (e.g. if you destroy the slider on a next click),\r\n           * it doesn't throw an error.\r\n           */\r\n          if (typeof (position) !== 'undefined') {\r\n            value = slider.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;\r\n            // plugin values to be animated\r\n            setPositionProperty(value, 'slide', slider.settings.speed);\r\n          }\r\n          slider.working = false;\r\n        }\r\n        if (slider.settings.ariaHidden) { applyAriaHiddenAttributes(slider.active.index * getMoveBy()); }\r\n      };\r\n  \r\n      /**\r\n       * Transitions to the next slide in the show\r\n       */\r\n      el.goToNextSlide = function() {\r\n        // if infiniteLoop is false and last page is showing, disregard call\r\n        if (!slider.settings.infiniteLoop && slider.active.last) { return; }\r\n      if (slider.working == true){ return ;}\r\n        var pagerIndex = parseInt(slider.active.index) + 1;\r\n        el.goToSlide(pagerIndex, 'next');\r\n      };\r\n  \r\n      /**\r\n       * Transitions to the prev slide in the show\r\n       */\r\n      el.goToPrevSlide = function() {\r\n        // if infiniteLoop is false and last page is showing, disregard call\r\n        if (!slider.settings.infiniteLoop && slider.active.index === 0) { return; }\r\n      if (slider.working == true){ return ;}\r\n        var pagerIndex = parseInt(slider.active.index) - 1;\r\n        el.goToSlide(pagerIndex, 'prev');\r\n      };\r\n  \r\n      /**\r\n       * Starts the auto show\r\n       *\r\n       * @param preventControlUpdate (boolean)\r\n       *  - if true, auto controls state will not be updated\r\n       */\r\n      el.startAuto = function(preventControlUpdate) {\r\n        // if an interval already exists, disregard call\r\n        if (slider.interval) { return; }\r\n        // create an interval\r\n        slider.interval = setInterval(function() {\r\n          if (slider.settings.autoDirection === 'next') {\r\n            el.goToNextSlide();\r\n          } else {\r\n            el.goToPrevSlide();\r\n          }\r\n        }, slider.settings.pause);\r\n      //allback for when the auto rotate status changes\r\n      slider.settings.onAutoChange.call(el, true);\r\n        // if auto controls are displayed and preventControlUpdate is not true\r\n        if (slider.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('stop'); }\r\n      };\r\n  \r\n      /**\r\n       * Stops the auto show\r\n       *\r\n       * @param preventControlUpdate (boolean)\r\n       *  - if true, auto controls state will not be updated\r\n       */\r\n      el.stopAuto = function(preventControlUpdate) {\r\n        // if no interval exists, disregard call\r\n        if (!slider.interval) { return; }\r\n        // clear the interval\r\n        clearInterval(slider.interval);\r\n        slider.interval = null;\r\n      //allback for when the auto rotate status changes\r\n      slider.settings.onAutoChange.call(el, false);\r\n        // if auto controls are displayed and preventControlUpdate is not true\r\n        if (slider.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('start'); }\r\n      };\r\n  \r\n      /**\r\n       * Returns current slide index (zero-based)\r\n       */\r\n      el.getCurrentSlide = function() {\r\n        return slider.active.index;\r\n      };\r\n  \r\n      /**\r\n       * Returns current slide element\r\n       */\r\n      el.getCurrentSlideElement = function() {\r\n        return slider.children.eq(slider.active.index);\r\n      };\r\n  \r\n      /**\r\n       * Returns a slide element\r\n       * @param index (int)\r\n       *  - The index (zero-based) of the element you want returned.\r\n       */\r\n      el.getSlideElement = function(index) {\r\n        return slider.children.eq(index);\r\n      };\r\n  \r\n      /**\r\n       * Returns number of slides in show\r\n       */\r\n      el.getSlideCount = function() {\r\n        return slider.children.length;\r\n      };\r\n  \r\n      /**\r\n       * Return slider.working variable\r\n       */\r\n      el.isWorking = function() {\r\n        return slider.working;\r\n      };\r\n  \r\n      /**\r\n       * Update all dynamic slider elements\r\n       */\r\n      el.redrawSlider = function() {\r\n        // resize all children in ratio to new screen size\r\n        slider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());\r\n        // adjust the height\r\n        slider.viewport.css('height', getViewportHeight());\r\n        // update the slide position\r\n        if (!slider.settings.ticker) { setSlidePosition(); }\r\n        // if active.last was true before the screen resize, we want\r\n        // to keep it last no matter what screen size we end on\r\n        if (slider.active.last) { slider.active.index = getPagerQty() - 1; }\r\n        // if the active index (page) no longer exists due to the resize, simply set the index as last\r\n        if (slider.active.index >= getPagerQty()) { slider.active.last = true; }\r\n        // if a pager is being displayed and a custom pager is not being used, update it\r\n        if (slider.settings.pager && !slider.settings.pagerCustom) {\r\n          populatePager();\r\n          updatePagerActive(slider.active.index);\r\n        }\r\n        if (slider.settings.ariaHidden) { applyAriaHiddenAttributes(slider.active.index * getMoveBy()); }\r\n      };\r\n  \r\n      /**\r\n       * Destroy the current instance of the slider (revert everything back to original state)\r\n       */\r\n      el.destroySlider = function() {\r\n        // don't do anything if slider has already been destroyed\r\n        if (!slider.initialized) { return; }\r\n        slider.initialized = false;\r\n        $('.bx-clone', this).remove();\r\n        slider.children.each(function() {\r\n          if ($(this).data('origStyle') !== undefined) {\r\n            $(this).attr('style', $(this).data('origStyle'));\r\n          } else {\r\n            $(this).removeAttr('style');\r\n          }\r\n        });\r\n        if ($(this).data('origStyle') !== undefined) {\r\n          this.attr('style', $(this).data('origStyle'));\r\n        } else {\r\n          $(this).removeAttr('style');\r\n        }\r\n        $(this).unwrap().unwrap();\r\n        if (slider.controls.el) { slider.controls.el.remove(); }\r\n        if (slider.controls.next) { slider.controls.next.remove(); }\r\n        if (slider.controls.prev) { slider.controls.prev.remove(); }\r\n        if (slider.pagerEl && slider.settings.controls && !slider.settings.pagerCustom) { slider.pagerEl.remove(); }\r\n        $('.bx-caption', this).remove();\r\n        if (slider.controls.autoEl) { slider.controls.autoEl.remove(); }\r\n        clearInterval(slider.interval);\r\n        if (slider.settings.responsive) { $(window).unbind('resize', resizeWindow); }\r\n        if (slider.settings.keyboardEnabled) { $(document).unbind('keydown', keyPress); }\r\n        //remove self reference in data\r\n        $(this).removeData('bxSlider');\r\n      // remove global window handlers\r\n      $(window).off('blur', windowBlurHandler).off('focus', windowFocusHandler);\r\n      };\r\n  \r\n      /**\r\n       * Reload the slider (revert all DOM changes, and re-initialize)\r\n       */\r\n      el.reloadSlider = function(settings) {\r\n        if (settings !== undefined) { options = settings; }\r\n        el.destroySlider();\r\n        init();\r\n        //store reference to self in order to access public functions later\r\n        $(el).data('bxSlider', this);\r\n      };\r\n  \r\n      init();\r\n  \r\n      $(el).data('bxSlider', this);\r\n  \r\n      // returns the current jQuery object\r\n      return this;\r\n    };\r\n  \r\n  })(jQuery);\n\n\n// WEBPACK FOOTER //\n// ./src/js/lib/jquery.bxslide.js","// import {LoginBabel} from './login/login-babel.js';\r\n\r\n// new LoginBabel().$inject('#app');\r\nimport './lib/jquery.bxslide';\r\n\r\nimport './modules/header';\r\n\r\n\r\n$(function () {\r\n    $('.bxslider').bxSlider();\r\n    $('.tab-item').click(function () {\r\n        $(this).addClass(\"active\").siblings().removeClass(\"active\"); //切换选中的按钮高亮状态\r\n        var index=$(this).index('.tab-item'); //获取被按下按钮的索引值，需要注意index是从0开始的\r\n        $(\".card-tab-cont\").eq(index).show().siblings().hide();\r\n    })\r\n});\n\n\n// WEBPACK FOOTER //\n// ./src/js/course.js"],"sourceRoot":""}